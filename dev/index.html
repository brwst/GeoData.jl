<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GeoData.jl · GeoData.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GeoData.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>GeoData.jl</a><ul class="internal"><li><a class="tocitem" href="#Dimensions"><span>Dimensions</span></a></li><li><a class="tocitem" href="#Index-modes"><span>Index modes</span></a></li><li><a class="tocitem" href="#Array"><span>Array</span></a></li><li><a class="tocitem" href="#Stack"><span>Stack</span></a></li><li><a class="tocitem" href="#Series"><span>Series</span></a></li><li class="toplevel"><a class="tocitem" href="#Sources"><span>Sources</span></a></li><li><a class="tocitem" href="#GRD"><span>GRD</span></a></li><li><a class="tocitem" href="#NetCDF"><span>NetCDF</span></a></li><li><a class="tocitem" href="#GDAL"><span>GDAL</span></a></li><li><a class="tocitem" href="#SMAP"><span>SMAP</span></a></li><li><a class="tocitem" href="#Helper-methods"><span>Helper methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>GeoData.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GeoData.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rafaqz/GeoData.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GeoData.jl"><a class="docs-heading-anchor" href="#GeoData.jl">GeoData.jl</a><a id="GeoData.jl-1"></a><a class="docs-heading-anchor-permalink" href="#GeoData.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GeoData" href="#GeoData"><code>GeoData</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>GeoData</strong></p><p><a href="https://rafaqz.github.io/GeoData.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://rafaqz.github.io/GeoData.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://travis-ci.com/rafaqz/GeoData.jl"><img src="https://travis-ci.com/rafaqz/GeoData.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/rafaqz/GeoData.jl"><img src="https://codecov.io/gh/rafaqz/GeoData.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://img.shields.io/badge/Aquajl-%F0%9F%8C%A2-aqua.svg" alt="Aqua.jl Quality Assurance"/></a></p><p>GeoData.jl defines common types and methods for working with spatial data, such as 2 or multidimensional raster arrays, multi-array stacks, and series of stacks or arrays spread over multiple files. It provides a standardised interface that allows many source data types to be used with identical syntax.</p><p>Data loaded with GeoData.jl has some special properties:</p><ul><li>Plots are always oriented the right way. Even if you reverse or permute a <code>GeoArray</code> it will still plot the right way!</li><li>Regions and points selected with <code>Between</code> and <code>Contains</code> select the right points or whole intervals  no matter the order of the index or it&#39;s position in the cell.</li><li>For <code>Projected</code> mode <code>GRDarray</code> and <code>GDALarray</code> You can index in any projection you want to by setting the  <code>mappedcrs</code> keyword on construction. You don&#39;t even need to know the underlying projection, the conversion is  handled automatically. This means Lat/Lon <code>EPSG(4326)</code> can be used accross all sources seamlessly if you need that.</li><li>Packages building on GeoData.jl can treat <code>AbstractGeoSeries</code>, <code>AbstractGeoStack</code>, and <code>AbstrackGeoArray</code> as black boxes:<ul><li>The data could hold tiff or netcdf files, <code>Array</code>s in memory or <code>CuArray</code>s on the GPU - they will all behave in the same way.</li><li><code>AbstractGeoStack</code> can be a Netcdf or HDF5 file, or a <code>NamedTuple</code> of <code>GDALarray</code> holding <code>.tif</code> files, or all <code>GeoArray</code> in memeory, but be treated as if they are all the same thing.</li><li>Modelling packages do not have to deal with the specifics of spatial file types directly.</li></ul></li></ul><p>GeoData.jl extends <a href="https://github.com/rafaqz/DimensionalData.jl">DimensionalData.jl</a> so that spatial data can be indexed using named dimensions like <code>Lat</code> and <code>Lon</code>, <code>Ti</code> (time), which can also be used in most <code>Base</code> and <code>Statistics</code> methods like <code>mean</code> and <code>reduce</code> where <code>dims</code> arguments are required. Much of the behaviour is covered in the <a href="https://rafaqz.github.io/DimensionalData.jl/stable/">DimensionalData docs</a>.</p><p>GeoData.jl provides general types for holding spatial data: <code>GeoArray</code>, <code>GeoStack</code>,  and <code>GeoSeries</code>, and types specific to various backends for loading disk-based data. R <code>.grd</code> files can be loaded natively using <code>GRDarray</code> and <code>GRDstack</code>.  GDAL files can be loaded with <code>GDALarray</code> and GDALstack when  <a href="https://github.com/yeesian/ArchGDAL.jl">ArchGDAL.jl</a> (v0.5 or higher) is present.  NetCDF similarly can be loaded with <code>NCDarray</code> and <code>NCDstack</code> when <a href="https://github.com/Alexander-Barth/NCDatasets.jl">NCDatasets.jl</a> is available.</p><p>When HDF5.jl is available, files from the Soil Moisture Active Passive (<a href="https://smap.jpl.nasa.gov/">SMAP</a>) dataset can be loaded using <code>SMAPstack</code> or <code>SMAPseries</code> to load whole directories. This is both useful for users of SMAP, and a demonstration of the potential to build standardised interfaces  for custom spatial dataset formats like those used in SMAP.</p><p>Files can be written to disk in all formats using <code>write</code>, and can (with some caveats) be written to to different formats providing file-type conversion for spatial data.</p><p><strong>Warning: this is an MVP.</strong></p><p>It works quite well but spatial data is very complicated. Some things may break. Currently saving a Netcdf to a GDAL tif, or the reverse, projections are not totally accurate.</p><p>Eventually they will be, but converting projections and index conventions between formats is difficult. with many edge case problems. For now, assume the index is not exactly correct. <code>Between</code>, <code>Contains</code> and <code>bounds</code> are close approximatios, but may contain errors.</p><p><strong>Examples</strong></p><p>We&#39;ll load a file from disk, and do some manipulations and plotting.</p><p>Load GeoData, and NCDatasets, download file and load it to  an array. This netcdf file only has one layer, if it has more we  could use <code>NCDstack</code> instead.</p><pre><code class="language-julia">julia&gt; using GeoData, NCDatasets

julia&gt; url = &quot;https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc&quot;;

julia&gt; filename = download(url, &quot;tos_O1_2001-2002.nc&quot;);

julia&gt; A = NCDarray(filename)
NCDarray (named tos) with dimensions:
 Longitude (type Lon): Float64[1.0, 3.0, …, 357.0, 359.0] (Converted: Ordered Regular Intervals)
 Latitude (type Lat): Float64[-79.5, -78.5, …, 88.5, 89.5] (Converted: Ordered Regular Intervals)
 Time (type Ti): DateTime360Day[DateTime360Day(2001-01-16T00:00:00), DateTime360Day(2001-02-16T00:00:00), …, DateTime360Day(2002-11-16T00:00:00), DateTime360Day(2002-12-16T00:00:00)] (Sampled: Ordered Irregular Points)
and data: 180×170×24 Array{Union{Missing, Float32},3}
[:, :, 1]
 missing  missing     missing  …  271.437  271.445  271.459
 missing  missing     missing     271.438  271.445  271.459
...</code></pre><p>Now plot every third month in the first year, just using the regular index:</p><pre><code class="language-julia">julia&gt; using Plots

juila&gt; A[Ti(1:3:12)] |&gt; plot</code></pre><p><img src="https://raw.githubusercontent.com/rafaqz/GeoData.jl/media/four_pane_map.png" alt="Global ocean surface temperatures"/></p><p>Now plot Australia in the first month of 2001. Notice we are using lat/lon coordinates  and date/time instead of regular indexes:</p><pre><code class="language-julia">julia&gt; A[Ti(Near(DateTime360Day(2001, 01, 17))), 
         Lat(Between(0.0, -50.0)), 
         Lon(Between(100.0, 160.0))] |&gt; plot</code></pre><p><img src="https://raw.githubusercontent.com/rafaqz/GeoData.jl/media/aus.png" alt="Australia regional ocean surface temperature"/></p><p>Now get the mean over the timespan, then save it to disk, and plot it :</p><pre><code class="language-julia">julia&gt; using Statistics

julia&gt; mean_tos = mean(A; dims=Ti)
GeoArray (named tos) with dimensions:
 Longitude (type Lon): Float64[1.0, 3.0, …, 357.0, 359.0] (Converted: Ordered Regular Intervals)
 Latitude (type Lat): Float64[-79.5, -78.5, …, 88.5, 89.5] (Converted: Ordered Regular Intervals)
 Time (type Ti): DateTime360Day[2001-01-16T00:00:00] (Sampled: Ordered Irregular Points)
and data: 180×170×1 Array{Union{Missing, Float32},3}
[:, :, 1]
 missing  missing     missing     missing  …  271.434  271.443  271.454
 missing  missing     missing     missing     271.434  271.443  271.454
...

julia&gt; write(&quot;mean.ncd&quot;, NCDarray, mean_tos)
    Writing netcdf...
        key: &quot;longitude&quot; of type: Float64
        key: &quot;latitude&quot; of type: Float64
        key: &quot;time&quot; of type: DateTime360Day
        key: &quot;tos&quot; of type: Union{Missing, Float32}
&quot;mean.ncd&quot;

julia&gt; plot(mean_tos; color=:viridis) </code></pre><p><img src="https://raw.githubusercontent.com/rafaqz/GeoData.jl/media/mean.png" alt="Mean temperatures"/></p><p>Plotting recipes in DimensionalData.jl are the fallback for GedData.jl when  the object doesn&#39;t have both <code>Lat</code> and <code>Lon</code> dimensions. So (as a random example) we  could plot a transect of ocean surface temperature at 20 degree latitude :</p><pre><code class="language-julia">A[Lat(Near(20.0)), Ti(1)] |&gt; plot</code></pre><p><img src="https://raw.githubusercontent.com/rafaqz/GeoData.jl/media/lat_20.png" alt="Temperatures at lattitude 20-21"/></p><p>GeoData.jl provides a range of other methods that are being added to over time. One example is <code>aggregate</code>, that can aggregate <code>GeoArray</code> by axis-specific amounts:</p><pre><code class="language-julia">julia&gt; aggregate(mean, A, (Ti(12), Lat(20), Lon(20))

GeoArray (named tos) with dimensions:
 Longitude (type Lon): Float64[21.0, 61.0, …, 301.0, 341.0] (Converted: Ordered Regular Intervals)
 Latitude (type Lat): Float64[-69.5, -49.5, …, 50.5, 70.5] (Converted: Ordered Regular Intervals)
 Time (type Ti): DateTime360Day[2001-01-16T00:00:00, 2002-01-16T00:00:00] (Sampled: Ordered Irregular Points)
and data: 9×8×2 Array{Union{Missing, Float32},3}
[:, :, 1]
 missing  277.139        missing     missing     missing     missing  missing  missing
 missing  277.126        missing     missing     missing     missing  missing  missing</code></pre><p>This will also work for entire <code>GeoStacks</code> and <code>GeoSeries</code> using the same syntax.</p><p><strong>Works in progress</strong></p><ul><li>Integration with Vector/DataFrame spatial types and point/line/polygon data types. It should be possible to select polygons of data, and convert between linear datasets and array formats.</li><li>Standardised handling and conversion of spatial metadata between data formats</li><li>Handling complex projections: Affine transformation of dimensions to indices. AffineMaps will be stored as a wrapper dimension in <code>dims</code>.</li><li>Load and write the NetCDF projection format.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/GeoData.jl#L4-L188">source</a></section></article><h2 id="Dimensions"><a class="docs-heading-anchor" href="#Dimensions">Dimensions</a><a id="Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoXDim" href="#GeoData.GeoXDim"><code>GeoData.GeoXDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoXDim &lt;: Dimension.XDim</code></pre><p>Abstract supertype for GeoSpatial X dimensions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/dimensions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoYDim" href="#GeoData.GeoYDim"><code>GeoData.GeoYDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoXDim &lt;: Dimension.XDim</code></pre><p>Abstract supertype for GeoSpatial Y dimensions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/dimensions.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoZDim" href="#GeoData.GeoZDim"><code>GeoData.GeoZDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoZDim &lt;: Dimension.ZDim</code></pre><p>Abstract supertype for GeoSpatial Z dimensions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/dimensions.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Lat" href="#GeoData.Lat"><code>GeoData.Lat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lat &lt;: GeoYDim

Lat(val=:)</code></pre><p>Latitude <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Dimension"><code>Dimension</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia">vertdim = Lat(10:10:100)
# Or
val = A[Lat(1)]
# Or
mean(A; dims=Lat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Lon" href="#GeoData.Lon"><code>GeoData.Lon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lon &lt;: GeoXDim

Lon(val=:)</code></pre><p>Longitude <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Dimension"><code>Dimension</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia">longdim = Lon(10:10:100)
# Or
val = A[Lon(1)]
# Or
mean(A; dims=Lon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Vert" href="#GeoData.Vert"><code>GeoData.Vert</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Vert &lt;: GeoZDim

Vert(val=:)</code></pre><p>Vertical <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Dimension"><code>Dimension</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia">vertdim = Vert(10:10:100)
# Or
val = A[Vert(1)]
# Or
mean(A; dims=Vert)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Band" href="#GeoData.Band"><code>GeoData.Band</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Band &lt;: Dimension

Band(val=:)</code></pre><p>Band <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Dimension"><code>Dimension</code></a> for multi-band rasters.</p><p><strong>Example:</strong></p><pre><code class="language-julia">banddim = Band(10:10:100)
# Or
val = A[Band(1)]
# Or
mean(A; dims=Band)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L15">source</a></section></article><h2 id="Index-modes"><a class="docs-heading-anchor" href="#Index-modes">Index modes</a><a id="Index-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Index-modes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeoData.AbstractProjected" href="#GeoData.AbstractProjected"><code>GeoData.AbstractProjected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractProjected &lt;: AbstractSampled</code></pre><p>Abstract supertype for projected index modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/mode.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Projected" href="#GeoData.Projected"><code>GeoData.Projected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Projected &lt;: AbstractProjected

Projected(order::Order, span, sampling, crs, mappedcrs)
Projected(; order=Ordered(), span=AutoSpan(), sampling=Points(), crs, mappedcrs=nothing)</code></pre><p>An <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.AbstractSampled"><code>AbstractSampled</code></a> <code>IndexMode</code> with projections attached.</p><p>Fields and behaviours are identical to <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Sampled"><code>Sampled</code></a> with the addition of <code>crs</code> and <code>mappedcrs</code> fields.</p><p>If both <code>crs</code> and <code>mappedcrs</code> fields contain CRS data (in a <code>GeoFormat</code> wrapper from GeoFormatTypes.jl) the selector inputs and plot axes will be converted from and to the specified <code>mappedcrs</code> projection automatically. A common use case would be to pass <code>mappedcrs=EPSG(4326)</code> to the constructor when loading eg. a GDALarray:</p><pre><code class="language-julia">GDALarray(filename; mappedcrs=EPSG(4326))</code></pre><p>The underlying <code>crs</code> will be detected by GDAL.</p><p>If <code>mappedcrs</code> is not supplied (ie. <code>mappedcrs=nothing</code>), the base index will be shown on plots, and selectors will need to use whatever format it is in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/mode.jl#L11-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.Mapped" href="#GeoData.Mapped"><code>GeoData.Mapped</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Mapped &lt;: AbstractProjected

Mapped(order::Order, span, sampling, crs, mappedcrs)
Mapped(; order=Ordered(), span=AutoSpan(), sampling=Points(), crs=nothing, mappedcrs)</code></pre><p>An <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.AbstractSampled"><code>AbstractSampled</code></a> <code>IndexMode</code>, where the dimension index has been mapped to another projection, usually lat/lon or <code>EPSG(4326)</code>.</p><p>Fields and behaviours are identical to <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Sampled"><code>Sampled</code></a> with the addition of <code>crs</code> and <code>mappedcrs</code> fields.</p><p>The mapped dimension index will be used as for <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Sampled"><code>Sampled</code></a>, but to save in another format the underlying <code>projectioncrs</code> may be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/mode.jl#L62-L76">source</a></section></article><h2 id="Array"><a class="docs-heading-anchor" href="#Array">Array</a><a id="Array-1"></a><a class="docs-heading-anchor-permalink" href="#Array" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeoData.AbstractGeoArray" href="#GeoData.AbstractGeoArray"><code>GeoData.AbstractGeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGeoArray &lt;: DimensionalData.AbstractDimArray</code></pre><p>Abstract supertype for objects that wrap an array (or location of an array)  and metadata about its contents. It may be memory (<a href="#GeoData.GeoArray"><code>GeoArray</code></a>) or disk-backed (<a href="#GeoData.NCDarray"><code>NCDarray</code></a>, <a href="#GeoData.GDALarray"><code>GDALarray</code></a>, <a href="#GeoData.GRDarray"><code>GRDarray</code></a>).</p><p><code>AbstractGeoArray</code>s inherit from <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.AbstractDimensionalArray"><code>AbstractDimArray</code></a> from DimensionalData.jl. They can be indexed as regular Julia arrays or with DimensionalData.jl <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Dimension"><code>Dimension</code></a>s. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with <code>getindex</code> or <code>view</code>. <code>getindex</code> on a <code>AbstractGeoArray</code> will always return a memory-backed <code>GeoArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.MemGeoArray" href="#GeoData.MemGeoArray"><code>GeoData.MemGeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for all memory-backed GeoArrays where the data is an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L103-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.DiskGeoArray" href="#GeoData.DiskGeoArray"><code>GeoData.DiskGeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiskGeoArray &lt;: AbstractGeoArray</code></pre><p>Abstract supertype for all disk-backed GeoArrays. For these the data is lazyily loaded from disk.</p><p>To load a <code>DiskGeoArray</code> and operate on the data multiple times, use <a href="#Base.open"><code>open</code></a> and a <code>do</code> block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoArray" href="#GeoData.GeoArray"><code>GeoData.GeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoArray &lt;: MemGeoArray

GeoArray(A::AbstractArray{T,N}, dims::Tuple; kw...)
GeoArray(A::AbstractArray{T,N}; dims, kw...)
GeoArray(A::AbstractGeoArray; kw...) =</code></pre><p>A generic, memory-backed spatial array type. All <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a> are converted to <code>GeoArray</code> when indexed or otherwise transformed.</p><p><strong>Keywords</strong></p><ul><li><code>data</code>: can replace the data in an <code>AbstractGeoArray</code></li><li><code>dims</code>: <code>Tuple</code> of <code>Dimension</code>s for the array.</li><li><code>refdims</code>: <code>Tuple of</code> position <code>Dimension</code>s the array was sliced from,   defaulting to <code>()</code>.</li><li><code>name</code>: <code>Symbol</code> name for the array.</li><li><code>missingval</code>: Value reprsenting missing values, defaulting to <code>missing</code>.   can be passed it.</li><li><code>metadata</code>: <code>ArrayMetadata</code> object for the array, or <code>NoMetadata()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L175-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.OpenGeoArray" href="#GeoData.OpenGeoArray"><code>GeoData.OpenGeoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OpenGeoArray &lt;: AbstractGeoArray</code></pre><p>Used internally to expose open disk files inside a <code>do</code> block</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/open.jl#L2-L6">source</a></section></article><h2 id="Stack"><a class="docs-heading-anchor" href="#Stack">Stack</a><a id="Stack-1"></a><a class="docs-heading-anchor-permalink" href="#Stack" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeoData.AbstractGeoStack" href="#GeoData.AbstractGeoStack"><code>GeoData.AbstractGeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGeoStack</code></pre><p>Abstract supertype for objects that hold multiple <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a> that share spatial bounds.</p><p>They are <code>NamedTuple</code>-like structures that may either contain <code>NamedTuple</code> of <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a>, string paths that will load <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a>, or a single path that points to as a file itself containing multiple layers, like NetCDF or HDF5. Use and syntax is similar or identical for all cases.</p><p><code>getindex</code> on a <code>AbstractGeoStack</code> generally returns a memory backed standard <a href="#GeoData.GeoArray"><code>GeoArray</code></a>. <code>geoarray[:somelayer] |&gt; plot</code> plots the layers array, while <code>geoarray[:somelayer, Lon(1:100), Band(2)] |&gt; plot</code> will plot the subset without loading the whole array.</p><p><code>getindex</code> on a <code>AbstractGeoStack</code> with a key returns another stack with getindex applied to all the arrays in the stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.MemGeoStack" href="#GeoData.MemGeoStack"><code>GeoData.MemGeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MemGeoStack &lt;: AbstractGeoStack</code></pre><p>Abstract supertype for <a href="#GeoData.AbstractGeoStack"><code>AbstractGeoStack</code></a> stored in memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoStack" href="#GeoData.GeoStack"><code>GeoData.GeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoStack &lt;: MemGeoStack

GeoStack(data...; keys, kwargs...)
GeoStack(data::Union{Vector,Tuple}; keys, kwargs...)
GeoStack(data::NamedTuple; window=(), metadata=nothing, refdims=(), childkwargs=()) =
GeoStack(s::AbstractGeoStack; [keys, data, refdims, window, metadata])</code></pre><p>A concrete <code>MemGeoStack</code> implementation. Holds layers of <a href="#GeoData.GeoArray"><code>GeoArray</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: A <code>NamedTuple</code> of <a href="#GeoData.GeoArray"><code>GeoArray</code></a>, or a <code>Vector</code>, <code>Tuple</code> or splatted arguments   of <a href="#GeoData.GeoArray"><code>GeoArray</code></a>. The latter options must pass a <code>keys</code> keyword argument.</li></ul><p><strong>Keywords</strong></p><ul><li><code>keys</code>: Used as stack keys when a <code>Tuple</code> or <code>Vector</code> or splat of geoarrays are passed in.</li><li><code>window</code>: A <code>Tuple</code> of <code>Dimension</code>/<code>Selector</code>/indices that will be applied to the   contained arrays when they are accessed.</li><li><code>refdims</code>: Reference dimensions from earlier subsetting.</li><li><code>metadata</code>: Metadata as a <code>DimensionalData.AbstractStackMetadata</code> object.</li><li><code>childkwargs</code>: A <code>NamedTuple</code> of keyword arguments to pass to the constructor.</li><li><code>refdims</code>: <code>Tuple</code> of  position <code>Dimension</code> the array was sliced from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L294-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.DiskGeoStack" href="#GeoData.DiskGeoStack"><code>GeoData.DiskGeoStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiskGeoStack &lt;: AbstractGeoStack</code></pre><p>Abstract supertype of <a href="#GeoData.AbstractGeoStack"><code>AbstractGeoStack</code></a>s stored on disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.DiskStack" href="#GeoData.DiskStack"><code>GeoData.DiskStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiskStack(filenames...; keys, kw...)
DiskStack(filenames; keys, kw...)
DiskStack(filenames::NamedTuple; kw...)</code></pre><p>Concrete <a href="#GeoData.DiskGeoStack"><code>DiskGeoStack</code></a> implementation. Loads a stack of files lazily from disk.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: a NamedTuple of stack keys and <code>String</code> filenames.</li></ul><p><strong>Keywords</strong></p><ul><li><code>keys</code>: Used as stack keys when a <code>Tuple</code>, <code>Vector</code> or splat of filenames are passed in.</li><li><code>window</code>: A <code>Tuple</code> of <code>Dimension</code>/<code>Selector</code>/indices that will be applied to the   contained arrays when they are accessed.</li><li><code>metadata</code>: Metadata as a <code>DimensionalData.StackMetadata</code> object.</li><li><code>childtype</code>: The type of the child data. eg. <code>GDALarray</code>. Required.</li><li><code>childkwargs</code>: A <code>NamedTuple</code> of keyword arguments to pass to the <code>childtype</code> constructor.</li><li><code>refdims</code>: <code>Tuple</code> of  position <code>Dimension</code> the array was sliced from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L349-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPstack" href="#GeoData.SMAPstack"><code>GeoData.SMAPstack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SMAPstacka &lt;: DiskGeoStack

SMAPstack(filename::String; dims=nothing, refdims=nothing, window=())</code></pre><p><code>AbstractGeoStack</code> for <a href="https://smap.jpl.nasa.gov/">SMAP</a> datasets.</p><p>The simplicity of the format means <code>dims</code> and <code>metadata</code> are the same for all stack layers, so we store them as stack fields.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>String</code> path to a SMAP .h5 file.</li></ul><p><strong>Keywords</strong></p><ul><li><code>dims</code>: Dimensions held on the stack as all layers have identical <code>Dimension</code>s.   These are loaded from the HDF5 by default, but can be passed in to improve performance,   as is done by <a href="#GeoData.SMAPseries"><code>SMAPseries</code></a>,</li><li><code>refdims</code>: As for <code>dims</code>. Often the position time <code>Dimension</code> from the <code>SMAPseries</code>.</li><li><code>metadata</code>: <a href="#GeoData.SMAPstackMetadata"><code>SMAPstackMetadata</code></a> object. As for <code>dims</code>.</li><li><code>window</code>: Like <code>view</code> but lazy, for disk based data. Can be a tuple of Dimensions,   selectors or regular indices. These will be applied when the data is loaded or indexed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/smap.jl#L50-L73">source</a></section></article><h2 id="Series"><a class="docs-heading-anchor" href="#Series">Series</a><a id="Series-1"></a><a class="docs-heading-anchor-permalink" href="#Series" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeoData.AbstractGeoSeries" href="#GeoData.AbstractGeoSeries"><code>GeoData.AbstractGeoSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGeoSeries &lt;: DimensionalData.AbstractDimensionalArray</code></pre><p>Abstract supertype for high-level <code>DimensionalArray</code> that hold stacks, arrays, or the paths they can be loaded from. <code>GeoSeries</code> are indexed with dimensions as with a <code>AbstractGeoArray</code>. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation. As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.</p><p>This allows syntax like:</p><pre><code class="language-julia">series[Time(Near(DateTime(2001, 1))][:temp][Lat(Between(70, 150)), Lon(Between(-20,20))] |&gt; plot`</code></pre><p><code>GeoSeries</code> is the only concrete implementation. It includes a <code>chiltype</code> field indicating the constructor used then loading stacks or arrays of any type from disk, and holds a <code>kwargs</code> <code>NamedTuple</code> that will be splatted into to the keyword arguments of the <code>childtype</code> constructor. This gives control over the construction of lazy-loaded files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/series.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GeoSeries" href="#GeoData.GeoSeries"><code>GeoData.GeoSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeoSeries &lt;: AbstractGeoSeries

GeoSeries(A::AbstractArray{&lt;:AbstractGeoArray}, dims; kw...)
GeoSeries(A::AbstractArray{&lt;:AbstractGeoStack}, dims; kw...)
GeoSeries(filenames::AbstractArray{&lt;:AbstractString}, dims; kw...)</code></pre><p>Concrete implementation of <a href="#GeoData.AbstractGeoSeries"><code>AbstractGeoSeries</code></a>. Series hold paths to array or stack files, along some dimension(s).</p><p><strong>Keywords</strong></p><ul><li><code>refdims</code>: existing reference </li><li><code>childtype</code>: type of child objects - an <code>AbstractGeoSeries</code> or <code>AbstractGeoStack</code></li><li><code>childkwargs</code>: keyword arguments passed to the child object on construction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/series.jl#L75-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPseries" href="#GeoData.SMAPseries"><code>GeoData.SMAPseries</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SMAPseries(filenames::AbstractString; kw...)
SMAPseries(filenames::Vector{&lt;:AbstractString}, dims=nothing; kw...)</code></pre><p><a href="#GeoData.GeoSeries"><code>GeoSeries</code></a> loader for SMAP files and whole folders of files, organised along the time dimension. Returns a <a href="#GeoData.GeoSeries"><code>GeoSeries</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>filenames</code>: A <code>String</code> path to a directory of SMAP files,   or a vector of <code>String</code> paths to specific files.</li><li><code>dims</code>: <code>Tuple</code> containing <code>Ti</code> dimension for the series.   Automatically generated form <code>filenames</code> unless passed in.</li></ul><p><strong>Keywords</strong></p><ul><li><code>kw</code>: Passed to <code>GeoSeries</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/smap.jl#L142-L159">source</a></section></article><h1 id="Sources"><a class="docs-heading-anchor" href="#Sources">Sources</a><a id="Sources-1"></a><a class="docs-heading-anchor-permalink" href="#Sources" title="Permalink"></a></h1><h2 id="GRD"><a class="docs-heading-anchor" href="#GRD">GRD</a><a id="GRD-1"></a><a class="docs-heading-anchor-permalink" href="#GRD" title="Permalink"></a></h2><p>R GRD files can be loaded natively. The are always 3 dimensional, and have <a href="#GeoData.Lat"><code>Lat</code></a>, <a href="#GeoData.Lon"><code>Lon</code></a> and <a href="#GeoData.Band"><code>Band</code></a> dimensions.</p><p>If ArchGDAL.jl is loaded (to enable reprojection), they can have <a href="#GeoData.mappedcrs"><code>mappedcrs</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="GeoData.GRDarray" href="#GeoData.GRDarray"><code>GeoData.GRDarray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GRDarray &lt;: DiskGeoArray

GRDarray(filename::String; kw...)</code></pre><p>A <a href="#GeoData.DiskGeoArray"><code>DiskGeoArray</code></a> that loads .grd files lazily from disk.</p><p><code>GRDarray</code>s are always 3 dimensional, and have <a href="#GeoData.Lat"><code>Lat</code></a>, <a href="#GeoData.Lon"><code>Lon</code></a> and <a href="#GeoData.Band"><code>Band</code></a> dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>String</code> pointing to a grd file. Extension is optional.</li></ul><p><strong>Keywords</strong></p><ul><li><code>mappedcrs</code>: CRS format like <code>EPSG(4326)</code> used in <code>Selectors</code> like <code>Between</code> and <code>At</code>, and   for plotting. Can be any CRS <code>GeoFormat</code> from GeoFormatTypes.jl, like <code>WellKnownText</code>.</li><li><code>name</code>: <code>String</code> name for the array, taken from the files <code>layername</code> attribute unless passed in.</li><li><code>dims</code>: <code>Tuple</code> of <code>Dimension</code>s for the array. Detected automatically, but can be passed in.</li><li><code>refdims</code>: <code>Tuple of</code> position <code>Dimension</code>s the array was sliced from.</li><li><code>missingval</code>: Value reprsenting missing values. Detected automatically when possible, but   can be passed it.</li><li><code>metadata</code>: <code>Metadata</code> object for the array. Detected automatically as   <a href="#GeoData.GRDarrayMetadata"><code>GRDarrayMetadata</code></a>, but can be passed in.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">A = GRDarray(&quot;folder/file.grd&quot;; mappedcrs=EPSG(4326))
# Select Australia using lat/lon coords, whatever the crs is underneath.
A[Lat(Between(-10, -43), Lon(Between(113, 153)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/grd.jl#L144-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GRDstack" href="#GeoData.GRDstack"><code>GeoData.GRDstack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GRDstack(filenames; keys, kw...) =&gt; DiskStack
GRDstack(filenames...; keys, kw...) =&gt; DiskStack
GRDstack(filenames::NamedTuple; kw...) =&gt; DiskStack</code></pre><p>Convenience method to create a DiskStack of <a href="#GeoData.GRDarray"><code>GRDarray</code></a> from <code>filenames</code>.</p><p><strong>Arguments</strong></p><ul><li><code>filenames</code>: A NamedTuple of stack keys and <code>String</code> filenames, or a <code>Tuple</code>, <code>Vector</code> or splatted arguments of <code>String</code> filenames.</li></ul><p><strong>Keywords</strong></p><ul><li><code>keys</code>: Used as stack keys when a <code>Tuple</code>, <code>Vector</code> or splat of filenames are passed in.</li><li><code>window</code>: A <code>Tuple</code> of <code>Dimension</code>/<code>Selector</code>/indices that will be applied to the   contained arrays when they are accessed.</li><li><code>metadata</code>: Metadata as a <code>StackMetadata</code> object.</li><li><code>childkwargs</code>: A <code>NamedTuple</code> of keyword arguments to pass to the <code>childtype</code> constructor.</li><li><code>refdims</code>: <code>Tuple</code> of  position <code>Dimension</code> the array was sliced from.</li></ul><p><strong>Example</strong></p><p>Create a <code>GRDstack</code> from four files, that sets the child arrays <code>mappedcrs</code> value when they are loaded.</p><pre><code class="language-julia">files = (:temp=&quot;temp.tif&quot;, :pressure=&quot;pressure.tif&quot;, :relhum=&quot;relhum.tif&quot;)
stack = GRDstack(files; childkwargs=(mappedcrs=EPSG(4326),))
stack[:relhum][Lat(Contains(-37), Lon(Contains(144))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/grd.jl#L286-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GRDdimMetadata" href="#GeoData.GRDdimMetadata"><code>GeoData.GRDdimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GRDdimMetadata &lt;: AbstractDimMetadata

GRDdimMetadata(val::Union{Dict,NamedTuple})
GRDdimMetadata(pairs::Pair...) =&gt; GRDdimMetadata{Dict}
GRDdimMetadata(; kw...) =&gt; GRDdimMetadata{NamedTuple}</code></pre><p><code>Metadata</code> wrapper for <code>GRDarray</code> dimension metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/grd.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GRDarrayMetadata" href="#GeoData.GRDarrayMetadata"><code>GeoData.GRDarrayMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GRDarrayMetadata &lt;: AbstractArrayMetadata

GRDarrayMetadata(val::Union{Dict,NamedTuple})
GRDarrayMetadata(pairs::Pair...) =&gt; GRDarrayMetadata{Dict}
GRDarrayMetadata(; kw...) =&gt; GRDarrayMetadata{NamedTuple}</code></pre><p><code>Metadata</code> wrapper for <code>GRDarray</code> metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/grd.jl#L40-L48">source</a></section></article><h2 id="NetCDF"><a class="docs-heading-anchor" href="#NetCDF">NetCDF</a><a id="NetCDF-1"></a><a class="docs-heading-anchor-permalink" href="#NetCDF" title="Permalink"></a></h2><p>NetCDF files required NCDatasets.jl:</p><pre><code class="language-julia">import NCDatasets</code></pre><p>Single files can be treated as a array or a stack of arrays. </p><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDarray" href="#GeoData.NCDarray"><code>GeoData.NCDarray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NCDarray &lt;: DiskGeoArray

NCDarray(filename::AbstractString; name=nothing, refdims=(),
         dims=nothing, metadata=nothing, crs=nothing, mappedcrs=EPSG(4326))</code></pre><p>A <a href="#GeoData.DiskGeoArray"><code>DiskGeoArray</code></a> that loads that loads NetCDF files lazily from disk.</p><p>The first non-dimension layer of the file will be used as the array. Dims are usually detected as <a href="#GeoData.Lat"><code>Lat</code></a>, <a href="#GeoData.Lon"><code>Lon</code></a>, <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Ti"><code>Ti</code></a>, and [<code>Vert</code>] or possibly <code>X</code>, <code>Y</code>, <code>Z</code> when detected. Undetected dims will use the generic <code>Dim{:name}</code>.</p><p>This is an incomplete implementation of the NetCDF standard. It will currently handle simple files in lattitude/longitude projections, or projected formats if you manually specify <code>crs</code> and <code>mappedcrs</code>. How this is done may also change in future, including detecting and converting the native NetCDF projection format.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>String</code> pointing to a netcdf file.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>crs</code>: defaults to lat/lon <code>EPSG(4326)</code> but may be any <code>GeoFormat</code> like <code>WellKnownText</code>. If the underlying data is in a different projection <code>crs</code> will need to be set to allow <code>write</code> to a different file format. In future this may be detected automatically.</li><li><code>dimcrs</code>: The crs projection actually present in the Dimension index <code>Vector</code>, which may be different to the underlying projection. Defaults to lat/lon <code>EPSG(4326)</code> but may be any crs <code>GeoFormat</code>.</li><li><code>name</code>: <code>Symbol</code> name for the array. Will use array key if not supplied.</li><li><code>dims</code>: <code>Tuple</code> of <code>Dimension</code>s for the array. Detected automatically, but can be passed in.</li><li><code>refdims</code>: <code>Tuple of</code> position <code>Dimension</code>s the array was sliced from.</li><li><code>missingval</code>: Value reprsenting missing values. Detected automatically when possible, but can be passed it.</li><li><code>metadata</code>: <code>Metadata</code> object for the array. Detected automatically as <a href="#GeoData.NCDarrayMetadata"><code>NCDarrayMetadata</code></a>, but can be passed in.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">A = NCDarray(&quot;folder/file.ncd&quot;)
# Select Australia from the default lat/lon coords:
A[Lat(Between(-10, -43), Lon(Between(113, 153)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/ncdatasets.jl#L67-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDstack" href="#GeoData.NCDstack"><code>GeoData.NCDstack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NCDstack &lt;: DiskGeoStack

NCDstack(filename::String; refdims=(), window=(), metadata=nothing, childkwargs=())
NCDstack(filenames; keys, kw...)
NCDstack(filenames...; keys, kw...)
NCDstack(filenames::NamedTuple; refdims=(), window=(), metadata=nothing, childkwargs=())</code></pre><p>A lazy <a href="#GeoData.AbstractGeoStack"><code>AbstractGeoStack</code></a> that uses NCDatasets.jl to load NetCDF files. Can load a single multi-layer netcdf file, or multiple single-layer netcdf files. In multi-file mode it returns a regular <code>GeoStack</code> with a <code>childtype</code> of <a href="#GeoData.NCDarray"><code>NCDarray</code></a>.</p><p>Indexing into <code>NCDstack</code> with layer keys (<code>Symbol</code>s) returns a <a href="#GeoData.GeoArray"><code>GeoArray</code></a>. Dimensions are usually detected as <a href="#GeoData.Lat"><code>Lat</code></a>, <a href="#GeoData.Lon"><code>Lon</code></a>, <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Ti"><code>Ti</code></a>, and [<code>Vert</code>] or <code>X</code>, <code>Y</code>, <code>Z</code> when detected. Undetected dims use the generic <code>Dim{:name}</code>.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>Tuple</code> or <code>Vector</code> or splatted arguments of <code>String</code>, or single <code>String</code> path, to NetCDF files.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>keys</code>: Used as stack keys when a <code>Tuple</code>, <code>Vector</code> or splat of filenames are passed in. These default to the first non-dimension data key in each NetCDF file.</li><li><code>refdims</code>: Add dimension position array was sliced from. Mostly used programatically.</li><li><code>window</code>: A <code>Tuple</code> of <code>Dimension</code>/<code>Selector</code>/indices that will be applied to the contained arrays when they are accessed.</li><li><code>metadata</code>: A <a href="#GeoData.NCDstackMetadata"><code>NCDstackMetadata</code></a> object.</li><li><code>childkwargs</code>: A <code>NamedTuple</code> of keyword arguments to pass to the <a href="#GeoData.NCDarray"><code>NCDarray</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">stack = NCDstack(filename; window=(Lat(Between(20, 40),))
# Or
stack = NCDstack([fn1, fn1, fn3, fn4])
# And index with a layer key
stack[:soiltemp]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/ncdatasets.jl#L183-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDdimMetadata" href="#GeoData.NCDdimMetadata"><code>GeoData.NCDdimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NCDdimMetadata &lt;: AbstractDimMetadata

NCDdimMetadata(val::Union{Dict,NamedTuple})
NCDdimMetadata(pairs::Pair...) =&gt; NCDdimMetadata{Dict}
NCDdimMetadata(; kw...) =&gt; NCDdimMetadata{NamedTuple}</code></pre><p><code>Metadata</code> wrapper for <a href="#GeoData.NCDarray"><code>NCDarray</code></a> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/ncdatasets.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDarrayMetadata" href="#GeoData.NCDarrayMetadata"><code>GeoData.NCDarrayMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NCDarrayMetadata &lt;: AbstractArrayMetadata

NCDarrayMetadata(val::Union{Dict,NamedTuple})
NCDarrayMetadata(pairs::Pair...) =&gt; NCDarrayMetadata{Dict}
NCDarrayMetadata(; kw...) =&gt; NCDarrayMetadata{NamedTuple}</code></pre><p><code>Metadata</code> wrapper for <a href="#GeoData.NCDarray"><code>NCDarray</code></a> metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/ncdatasets.jl#L19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.NCDstackMetadata" href="#GeoData.NCDstackMetadata"><code>GeoData.NCDstackMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NCDstackMetadata &lt;: AbstractStackMetadata

NCDstackMetadata(val::Union{Dict,NamedTuple})
NCDstackMetadata(pairs::Pair...) =&gt; NCDstackMetadata{Dict}
NCDstackMetadata(; kw...) =&gt; NCDstackMetadata{NamedTuple}</code></pre><p><code>Metadata</code> wrapper for <a href="#GeoData.NCDarray"><code>NCDarray</code></a> metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/ncdatasets.jl#L32-L40">source</a></section></article><h2 id="GDAL"><a class="docs-heading-anchor" href="#GDAL">GDAL</a><a id="GDAL-1"></a><a class="docs-heading-anchor-permalink" href="#GDAL" title="Permalink"></a></h2><p>GDAL requires <a href="https://github.com/yeesian/ArchGDAL.jl/issues">ArchGDAL.jl</a> to be available: </p><pre><code class="language-julia">import ArchGDAL</code></pre><article class="docstring"><header><a class="docstring-binding" id="GeoData.GDALarray" href="#GeoData.GDALarray"><code>GeoData.GDALarray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GDALarray(filename; kw...)</code></pre><p>Load a file lazily using gdal. <code>GDALarray</code> will be converted to <a href="#GeoData.GeoArray"><code>GeoArray</code></a> after indexing or other manipulations. <code>GeoArray(GDALarray(filename))</code> will do this immediately.</p><p><code>GDALarray</code>s are always 3 dimensional, and have <a href="#GeoData.Lat"><code>Lat</code></a>, <a href="#GeoData.Lon"><code>Lon</code></a> and <a href="#GeoData.Band"><code>Band</code></a> dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: <code>String</code> pointing to a tif or other file that GDAL can load.</li></ul><p><strong>Keywords</strong></p><ul><li><code>crs</code>: crs to use instead of the detected crs</li><li><code>mappedcrs</code>: CRS format like <code>EPSG(4326)</code> used in <code>Selectors</code> like <code>Between</code> and <code>At</code>, and   for plotting. Can be any CRS <code>GeoFormat</code> from GeoFormatTypes.jl, like <code>WellKnownText</code>.</li><li><code>name</code>: <code>Symbol</code> name for the array.</li><li><code>dims</code>: <code>Tuple</code> of <code>Dimension</code>s for the array. Detected automatically, but can be passed in.</li><li><code>refdims</code>: <code>Tuple of</code> position <code>Dimension</code>s the array was sliced from.</li><li><code>missingval</code>: Value reprsenting missing values. Detected automatically when possible, but   can be passed it.</li><li><code>metadata</code>: <code>Metadata</code> object for the array. Detected automatically as   <a href="#GeoData.GDALarrayMetadata"><code>GDALarrayMetadata</code></a>, but can be passed in.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">A = GDALarray(&quot;folder/file.tif&quot;; mappedcrs=EPSG(4326))
# Select Australia using lat/lon coords, whatever the crs is underneath.
A[Lat(Between(-10, -43), Lon(Between(113, 153)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/gdal.jl#L46-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GDALstack" href="#GeoData.GDALstack"><code>GeoData.GDALstack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GDALstack(filenames; keys, kw...)
GDALstack(filenames...; keys, kw...)
GDALstack(filenames::NamedTuple; kw...)</code></pre><p>Convenience method to create a DiskStack  of <a href="#GeoData.GDALarray"><code>GDALarray</code></a> from <code>filenames</code>.</p><p>Load a stack of files lazily from disk.</p><p><strong>Arguments</strong></p><ul><li><code>filenames</code>: A NamedTuple of stack keys and <code>String</code> filenames, or a <code>Tuple</code>,   <code>Vector</code> or splatted arguments of <code>String</code> filenames.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>keys</code>: Used as stack keys when a <code>Tuple</code>, <code>Vector</code> or splat of filenames are passed in.</li><li><code>window</code>: A <code>Tuple</code> of <code>Dimension</code>/<code>Selector</code>/indices that will be applied to the   contained arrays when they are accessed.</li><li><code>metadata</code>: a <code>DimensionalData.StackMetadata</code> object.</li><li><code>childkwargs</code>: A <code>NamedTuple</code> of keyword arguments to pass to the <code>childtype</code> constructor.</li><li><code>refdims</code>: <code>Tuple</code> of  position <code>Dimension</code> the array was sliced from.</li></ul><p><strong>Example</strong></p><p>Create a <code>GDALstack</code> from four files, that sets the child arrays <code>mappedcrs</code> value when they are loaded.</p><pre><code class="language-julia">files = (:temp=&quot;temp.tif&quot;, :pressure=&quot;pressure.tif&quot;, :relhum=&quot;relhum.tif&quot;)
stack = GDALstack(files; childkwargs=(mappedcrs=EPSG(4326),))
stack[:relhum][Lat(Contains(-37), Lon(Contains(144))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/gdal.jl#L160-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GDALdimMetadata" href="#GeoData.GDALdimMetadata"><code>GeoData.GDALdimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GDALdimMetadata &lt;: AbstractDimMetadata

GDALdimMetadata(val::Union{Dict,NamedTuple})
GDALdimMetadata(pairs::Pair...) =&gt; GDALdimMetadata{Dict}
GDALdimMetadata(; kw...) =&gt; GDALdimMetadata{NamedTuple}</code></pre><p><code>Metadata</code> wrapper for <code>GDALarray</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/gdal.jl#L17-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.GDALarrayMetadata" href="#GeoData.GDALarrayMetadata"><code>GeoData.GDALarrayMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GDALarrayMetadata &lt;: AbstractArrayMetadata

GDALarrayMetadata(val::Union{Dict,NamedTuple})
GDALarrayMetadata(pairs::Pair...) =&gt; GDALarrayMetadata{Dict}
GDALarrayMetadata(; kw...) =&gt; GDALarrayMetadata{NamedTuple}</code></pre><p><code>Metadata</code> wrapper for <code>GDALarray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/gdal.jl#L30-L38">source</a></section></article><h2 id="SMAP"><a class="docs-heading-anchor" href="#SMAP">SMAP</a><a id="SMAP-1"></a><a class="docs-heading-anchor-permalink" href="#SMAP" title="Permalink"></a></h2><p>The <a href="https://smap.jpl.nasa.gov/">Soil Moisture Active-Passive</a> dataset provides global layers of soil moisture, temperature and other related data.</p><p>It uses a custom format of HDF5 files, so required HDF5.jl to be available:</p><pre><code class="language-julia">import HDF5</code></pre><p>Files must be downloaded manually due to authentication restrictions. As the datasets are know files in standardised formats, whole folders can be loaded using <a href="#GeoData.SMAPseries"><code>SMAPseries</code></a>. Methods like <code>aggregate</code> can be done over whole folders of stacks of data with a single command.</p><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPdimMetadata" href="#GeoData.SMAPdimMetadata"><code>GeoData.SMAPdimMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SMAPdimMetadata &lt;: AbstractDimMetadata

SMAPdimMetadata(val::Union{Dict,NamedTuple})
SMAPdimMetadata(pairs::Pair...) =&gt; SMAPdimMetadata{Dict}
SMAPdimMetadata(; kw...) =&gt; SMAPdimMetadata{NamedTuple}</code></pre><p><code>DimMetadata</code> wrapper for <code>SMAParray</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/smap.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAParrayMetadata" href="#GeoData.SMAParrayMetadata"><code>GeoData.SMAParrayMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SMAParrayMetadata &lt;: AbstractArrayMetadata

SMAParrayMetadata(val::Union{Dict,NamedTuple})
SMAParrayMetadata(pairs::Pair...) =&gt; SMAParrayMetadata{Dict}
SMAParrayMetadata(; kw...) =&gt; SMAParrayMetadata{NamedTuple}</code></pre><p><code>ArrayMetadata</code> wrapper for <code>SMAParray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/smap.jl#L22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.SMAPstackMetadata" href="#GeoData.SMAPstackMetadata"><code>GeoData.SMAPstackMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SMAPstackMetadata &lt;: AbstractStackMetadata

SMAPstackMetadata(val::Union{Dict,NamedTuple})
SMAPstackMetadata(pairs::Pair...) =&gt; SMAPstackMetadata{Dict}
SMAPstackMetadata(; kw...) =&gt; SMAPstackMetadata{NamedTuple}</code></pre><p><code>StackMetadata</code> wrapper for <code>SMAPstack</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/smap.jl#L35-L43">source</a></section></article><h2 id="Helper-methods"><a class="docs-heading-anchor" href="#Helper-methods">Helper methods</a><a id="Helper-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-methods" title="Permalink"></a></h2><p>See <a href="https://rafaqz.github.io/DimensionalData.jl/stable/">DimensionalData.jl docs</a> for the majority of types and methods that can be used in GeoData.jl.  GeoData.jl is a direct extension of DimensionalData.jl.</p><p>These methods are specific to GeoData.jl:</p><article class="docstring"><header><a class="docstring-binding" id="GeoData.replace_missing" href="#GeoData.replace_missing"><code>GeoData.replace_missing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">replace_missing(a::AbstractGeoArray, newmissingval)
replace_missing(a::AbstractGeoStack, newmissingval)</code></pre><p>Replace missing values in the array or stack with a new missing value, also updating the <code>missingval</code> field/s.</p><p>A <code>GeoArray</code> containing a newly allocated <code>Array</code> is always returned, even when the missing value matches the current value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/methods.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.resample" href="#GeoData.resample"><code>GeoData.resample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resample(A::AbstractGeoArray, resolution::Number;
		 crs::GeoFormat=crs(A), method::String=&quot;near&quot;)
resample(A::AbstractGeoArray, snap::AbstractGeoArray; method::String=&quot;near&quot;)</code></pre><p><code>resample</code> uses <code>ArchGDAL.gdalwarp</code> to resample an <code>AbstractGeoArray</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: The <code>AbstractGeoArray</code> to resample.</li><li><code>resolution</code>: A <code>Number</code> specifying the resolution for the output.   If the keyword argument <code>crs</code> (described below) is specified, <code>resolution</code> must be in units of the <code>crs</code>.</li><li><code>snap</code>: an <code>AbstractGeoArray</code> whos resolution, crs and bounds will be snapped to.   For best results it should roughly cover the same extent, or a subset of <code>A</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>crs</code>: A <code>GeoFormatTypes.GeoFormat</code> specifying an output crs   (<code>A</code> with be reprojected to <code>crs</code> in addition to being resampled). Defaults to <code>crs(A)</code></li><li><code>method</code>: A <code>String</code> specifying the method to use for resampling. Defaults to <code>&quot;near&quot;</code>   (nearest neighbor resampling). See <a href="https://gdal.org/programs/gdalwarp.html#cmdoption-gdalwarp-r">resampling method</a>   in the gdalwarp docs for a complete list of possible values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/resample.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.boolmask" href="#GeoData.boolmask"><code>GeoData.boolmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">boolmask(A::AbstractArray, [missingval])</code></pre><p>Create a mask array of <code>Bool</code> values, from any AbstractArray. For <code>AbstractGeoArray</code> the default <code>missingval</code> is <code>missingval(A)</code>, for all other <code>AbstractArray</code>s it is <code>missing</code>.</p><p>The array returned from calling <code>boolmask</code> on a <code>AbstractGeoArray</code> is a <a href="#GeoData.GeoArray"><code>GeoArray</code></a> with the same size and fields as the oridingl array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/methods.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.missingmask" href="#GeoData.missingmask"><code>GeoData.missingmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">missingmask(A::AbstractArray, [missingval])</code></pre><p>Create a mask array of <code>missing</code> or <code>true</code> values, from any AbstractArray. For <code>AbstractGeoArray</code> the default <code>missingval</code> is <code>missingval(A)</code>, for all other <code>AbstractArray</code>s it is <code>missing</code>.</p><p>The array returned from calling <code>boolmask</code> on a <code>AbstractGeoArray</code> is a <a href="#GeoData.GeoArray"><code>GeoArray</code></a> with the same size and fields as the oridingl array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/methods.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate" href="#GeoData.aggregate"><code>GeoData.aggregate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aggregate(method, object, scale)</code></pre><p>Aggregate array, or all arrays in a stack or series, by some scale.</p><p><strong>Arguments</strong></p><ul><li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Locus"><code>Locus</code></a> like <code>Start()</code> or <code>Center()</code> that species where to sample from in the interval.</li><li><code>object</code>: Object to aggregate, like <code>AbstractGeoSeries</code>, <code>AbstractStack</code>, <code>AbstractGeoArray</code>, <code>Dimension</code></li><li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/aggregate.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.aggregate!" href="#GeoData.aggregate!"><code>GeoData.aggregate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aggregate!(method, dst::AbstractDimArray, src::AbstractDimArray, scale)</code></pre><p>Aggregate array <code>src</code> to array <code>dst</code> by <code>scale</code>, using <code>method</code>.</p><p><strong>Arguments</strong></p><ul><li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Locus"><code>Locus</code></a> like <code>Start()</code> or <code>Center()</code> that species where to sample from in the interval.</li><li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index in the <code>src</code> array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/aggregate.jl#L99-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.disaggregate" href="#GeoData.disaggregate"><code>GeoData.disaggregate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">disaggregate(method, object, scale)</code></pre><p>Disaggregate array, or all arrays in a stack or series, by some scale.</p><p><strong>Arguments</strong></p><ul><li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Locus"><code>Locus</code></a> like <code>Start()</code> or <code>Center()</code> that species where to sample from in the interval.</li><li><code>object</code>: Object to aggregate, like <code>AbstractGeoSeries</code>, <code>AbstractStack</code>, <code>AbstractGeoArray</code>, <code>Dimension</code></li><li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/aggregate.jl#L137-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.disaggregate!" href="#GeoData.disaggregate!"><code>GeoData.disaggregate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">disaggregate!(method, dst::AbstractDimArray, src::AbstractDimArray, scale)</code></pre><p>Disaggregate array <code>src</code> to array <code>dst</code> by some scale, using <code>method</code>.</p><ul><li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Locus"><code>Locus</code></a> like <code>Start()</code> or <code>Center()</code> that species where to sample from in the interval.</li><li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index in the <code>src</code> array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/aggregate.jl#L227-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.convertmode" href="#GeoData.convertmode"><code>GeoData.convertmode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convertmode(dstmode::Type{&lt;:IndexMode}, x)</code></pre><p>Convert the dimension mode between <code>Projected</code> and <code>Mapped</code>. Other dimension modes pass through unchanged.</p><p>This is used to e.g. save a netcdf file to GeoTiff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/mode.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.reproject" href="#GeoData.reproject"><code>GeoData.reproject</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reproject(source::GeoFormat, target::GeoFormat, dim::Dimension, val)</code></pre><p><code>reproject</code> uses ArchGDAL.reproject, but implemented for a reprojecting a single dimension at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/reproject.jl#L21-L26">source</a></section></article><p>Field access:</p><article class="docstring"><header><a class="docstring-binding" id="GeoData.missingval" href="#GeoData.missingval"><code>GeoData.missingval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">missingval(x)</code></pre><p>Returns the value representing missing data in the dataset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.crs" href="#GeoData.crs"><code>GeoData.crs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crs(x)</code></pre><p>Get the projected coordinate reference system of a <code>Lat</code> or <code>Lon</code> <code>Dimension</code>, or of the <code>Lat</code>/<code>Lon</code> dims of an <code>AbstractGeoArray</code>.</p><p>For <a href="#GeoData.Mapped"><code>Mapped</code></a> mode this may be <code>nothing</code> as there may be not projected coordinate reference system at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.mappedcrs" href="#GeoData.mappedcrs"><code>GeoData.mappedcrs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mappedcrs(x)</code></pre><p>Get the mapped coordinate reference system for the <code>Lat</code>/<code>Lon</code> dims of an array.</p><p>In <a href="#GeoData.Projected"><code>Projected</code></a> mode this is used to convert <a href="https://rafaqz.github.io/DimensionalData.jl/stable/api/#DimensionalData.Selector"><code>Selector</code></a> values form the mappedcrs defined projection to the underlying projection, and to show plot axes in the mapped projection.</p><p>In <code>Mapped</code> mode this is the coordinate reference system of the index values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.mappedbounds" href="#GeoData.mappedbounds"><code>GeoData.mappedbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mappedbounds(x)</code></pre><p>Get the bounds converted to the <a href="#GeoData.mappedcrs"><code>mappedcrs</code></a> value.</p><p>Whithout ArchGDAL loaded, this is just the regular bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/dimensions.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.mappedindex" href="#GeoData.mappedindex"><code>GeoData.mappedindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mappedindex(x)</code></pre><p>Get the index value of a dimension converted to the <code>mappedcrs</code> value.</p><p>Whithout ArchGDAL loaded, this is just the regular dim value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/dimensions.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.data" href="#DimensionalData.data"><code>DimensionalData.data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">data(f, A::DiskGeoArray)</code></pre><p>Run method <code>f</code> on the data source object for <code>A</code>, as passed by the <code>withdata</code> method for the array. The only requirement of the object is that it has an <code>Array</code> method that returns the data as an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/array.jl#L121-L127">source</a></section></article><p>Not exported:</p><article class="docstring"><header><a class="docstring-binding" id="GeoData.filename" href="#GeoData.filename"><code>GeoData.filename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filename(s::DiskGeoStack)</code></pre><p>Return the filename field of a <code>DiskGeoStack</code>. This may be a <code>Vector</code> of <code>String</code>, or a <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L223-L228">source</a></section><section><div><pre><code class="language-none">filename(s::DiskGeoStack, key)</code></pre><p>Return the filename field of a <code>DiskGeoStack</code> for a given key.</p><p>This will always be a single string. However, in some cases all keys may have the same filename.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L230-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeoData.childkwargs" href="#GeoData.childkwargs"><code>GeoData.childkwargs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">childkwargs(s::AbstractGeoStack)</code></pre><p>Returns the keyword arguments that will be passed to the child array constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L31-L35">source</a></section></article><p>These Base and DimensionalData methods have specific GeoData.jl version:</p><article class="docstring"><header><a class="docstring-binding" id="Base.open" href="#Base.open"><code>Base.open</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">open(f, A::AbstractGeoArray)</code></pre><p><code>open</code> is used to open any <code>AbstractGeoArray</code> and do multiple operations on it in a safe way. It&#39;s a shorthand for the unexported <code>OpenGeoArray</code> constructor.</p><p><code>f</code> is a method that accepts a single argument - an <code>OpenGeoArray</code> object which is just an <code>AbstractGeoArray</code> that holds an open disk - based object. Often it will be a <code>do</code> block:</p><pre><code class="language-julia">ga = GDALarray(filepath)
open(ga) do A
    A[I...] # A is an `OpenGeoArray` wrapping the disk-based object.
    # ...  multiple things you need to do with the open file
end</code></pre><p>By using a do block to open file we ensure they are always closed again after we finish working with them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/open.jl#L27-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write" href="#Base.write"><code>Base.write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.write(filename::AbstractString, T::Type{&lt;:AbstractGeoArray}, s::AbstractGeoStack)</code></pre><p>Save all layers of an <code>AbstractGeoStack</code> to separate files, using the backend determined by <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">write(filename, GDALarray, A)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L117-L128">source</a></section><section><div><pre><code class="language-none">Base.write(filename::AbstractString, ::Type{GRDarray}, s::AbstractGeoArray)</code></pre><p>Write a <a href="#GeoData.GRDarray"><code>GRDarray</code></a> to a .grd file, with a .gri header file. The extension of <code>filename</code> will be ignored.</p><p>Currently the <code>metadata</code> field is lost on <code>write</code> for <code>GRDarray</code>.</p><p>Returns <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/grd.jl#L209-L218">source</a></section><section><div><pre><code class="language-none">Base.write(filename::AbstractString, ::Type{GDALarray}, A::AbstractGeoArray;
    driver=&quot;GTiff&quot;, compress=&quot;DEFLATE&quot;, tiled=true
)</code></pre><p>Write a <a href="#GeoData.GDALarray"><code>GDALarray</code></a> to file, <code>.tif</code> by default, but other GDAL drivers also work.</p><p>GDAL flags <code>driver</code>, <code>compress</code> and <code>tiled</code> can be passed in as keyword arguments.</p><p>Returns <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/gdal.jl#L116-L126">source</a></section><section><div><pre><code class="language-none">Base.write(filename::AbstractString, ::Type{NCDarray}, s::AbstractGeoArray)</code></pre><p>Write an NCDarray to a NetCDF file using NCDatasets.jl</p><p>Returns <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/ncdatasets.jl#L162-L168">source</a></section><section><div><pre><code class="language-none">Base.write(filename::AbstractString, ::Type{NCDstack}, s::AbstractGeoStack)</code></pre><p>Write an NCDstack to a single netcdf file, using NCDatasets.jl.</p><p>Currently <code>DimMetadata</code> is not handled, and <code>ArrayMetadata</code> from other <a href="#GeoData.AbstractGeoArray"><code>AbstractGeoArray</code></a> @types is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/sources/ncdatasets.jl#L267-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)</code></pre><p>Concatenate all or a subset of layers for all passed in stacks.</p><p><strong>Keywords</strong></p><ul><li><code>keys</code>: <code>Tuple</code> of <code>Symbol</code> for the stack keys to concatenate.</li><li><code>dims</code>: Dimension of child array to concatenate on.</li></ul><p><strong>Example</strong></p><p>Concatenate the :sea<em>surface</em>temp and :humidity layers in the time dimension:</p><pre><code class="language-julia">cat(stacks...; keys=(:sea_surface_temp, :humidity), dims=Ti)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L92-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy!" href="#Base.copy!"><code>Base.copy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.copy!(dst::AbstractArray, src::DiskGeoStack, key::Key)</code></pre><p>Copy the stack layer <code>key</code> to <code>dst</code>, which can be any <code>AbstractArray</code>.</p><p><strong>Example</strong></p><p>Copy the <code>:humidity</code> layer from <code>stack</code> to <code>array</code>.</p><pre><code class="language-julia">copy!(array, stack, :humidity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L77-L89">source</a></section><section><div><pre><code class="language-none">Base.copy!(dst::AbstractGeoStack, src::AbstractGeoStack, [keys=keys(dst)])</code></pre><p>Copy all or a subset of layers from one stack to another.</p><p><strong>Example</strong></p><p>Copy just the <code>:sea_surface_temp</code> and <code>:humidity</code> layers from <code>src</code> to <code>dst</code>.</p><pre><code class="language-julia">copy!(dst::AbstractGeoStack, src::AbstractGeoStack, keys=(:sea_surface_temp, :humidity))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L178-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DimensionalData.modify" href="#DimensionalData.modify"><code>DimensionalData.modify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modify(f, series::AbstractGeoStack)</code></pre><p>Apply function <code>f</code> to the data of the child <code>AbstractGeoArray</code>s.</p><p><code>f</code> must return an idenically sized array.</p><p>This method triggers a complete rebuild of all objects, and disk based objects will be transferred to memory.</p><p>This is useful for swapping out array backend for an entire stack to <code>CuArray</code> from CUDA.jl to copy data to a GPU, and potentially other types like <code>DAarray</code> from Distributed.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/stack.jl#L41-L54">source</a></section><section><div><pre><code class="language-none">modify(f, series::AbstractGeoSeries)</code></pre><p>Apply function <code>f</code> to the data of the child object. If the child is an <code>AbstractGeoStack</code> the function will be passed on to its child <code>AbstractGeoArray</code>s.</p><p><code>f</code> must return an idenically sized array.</p><p>This method triggers a complete rebuild of all objects, and disk based objects will be transferred to memory.</p><p>This is useful for swapping out array backend for an entire series to <code>CuArray</code> from CUDA.jl to copy data to a GPU, and potentially other types like <code>DAarray</code> from Distributed.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rafaqz/GeoData.jl/blob/41aa84cc4825f7b4c9059b6042cbe8406daae232/src/series.jl#L34-L49">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 February 2021 05:16">Monday 22 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
