var documenterSearchIndex = {"docs":
[{"location":"#GeoData.jl","page":"GeoData.jl","title":"GeoData.jl","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GeoData","category":"page"},{"location":"#GeoData","page":"GeoData.jl","title":"GeoData","text":"GeoData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nGeoData.jl defines common types and methods for working with spatial data, such as 2 or multidimensional raster arrays, multi-array stacks, and series of stacks or arrays spread over multiple files. It provides a standardised interface that allows many source data types to be used with identical syntax.\n\nData loaded with GeoData.jl has some special properties:\n\nPlots are always oriented the right way. Even if you reverse or permute a GeoArray it will still plot the right way!\nRegions and points selected with Between and Contains select the right points or whole intervals  no matter the order of the index or it's position in the cell.\nFor Projected mode GRDarray and GDALarray You can index in any projection you want to by setting the  mappedcrs keyword on construction. You don't even need to know the underlying projection, the conversion is  handled automatically. This means lat/lon EPSG(4326) can be used across all sources seamlessly if you need that.\nPackages building on GeoData.jl can treat AbstractGeoSeries, AbstractGeoStack, and AbstrackGeoArray as black boxes:\nThe data could hold tiff or netcdf files, Arrays in memory or CuArrays on the GPU - they will all behave in the same way.\nAbstractGeoStack can be a Netcdf or HDF5 file, or a NamedTuple of GDALarray holding .tif files, or all GeoArray in memory, but be treated as if they are all the same thing.\nModelling packages do not have to deal with the specifics of spatial file types directly.\n\nGeoData.jl extends DimensionalData.jl so that spatial data can be indexed using named dimensions like Lat and Lon, Ti (time), which can also be used in most Base and Statistics methods like mean and reduce where dims arguments are required. Much of the behaviour is covered in the DimensionalData docs.\n\nGeoData.jl provides general types for holding spatial data: GeoArray, GeoStack, and GeoSeries, and types specific to various backends for loading disk-based data. All can be loaded using the functions geoarray, stack and series, that will guess the backend from the file type. R .grd files can be loaded natively, GDAL when ArchGDAL.jl (v0.5 or higher) is imported, and NetCDF can be loaded when NCDatasets.jl is imported.\n\nWhen HDF5.jl is imported, files from the Soil Moisture Active Passive (SMAP) dataset can be loaded with stack or series. This is both useful for users of SMAP, and a demonstration of the potential to build standardised interfaces for custom spatial dataset formats like those used in SMAP.\n\nFiles can be written to disk in all formats using write, and can (with some caveats) be written to to different formats providing file-type conversion for spatial data.\n\nWarning: this is an MVP.\n\nIt works quite well but spatial data is very complicated. Some things may break. Currently saving a Netcdf to a GDAL tif, or the reverse, projections are not totally accurate.\n\nEventually they will be, but converting projections and index conventions between formats is difficult. with many edge case problems. For now, assume the index is not exactly correct. Between, Contains and bounds are close approximatios, but may contain errors.\n\nExamples\n\nWe'll load a file from disk, and do some manipulations and plotting.\n\nLoad GeoData, and NCDatasets, download file and load it to  an array. This netcdf file only has one layer, if it has more we  could use NCDstack instead.\n\njulia> using GeoData, NCDatasets\n\njulia> url = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\n\njulia> filename = download(url, \"tos_O1_2001-2002.nc\");\n\njulia> A = geoarray(filename)\nNCDarray (named tos) with dimensions:\n Longitude (type Lon): Float64[1.0, 3.0, …, 357.0, 359.0] (Converted: Ordered Regular Intervals)\n Latitude (type Lat): Float64[-79.5, -78.5, …, 88.5, 89.5] (Converted: Ordered Regular Intervals)\n Time (type Ti): DateTime360Day[DateTime360Day(2001-01-16T00:00:00), DateTime360Day(2001-02-16T00:00:00), …, DateTime360Day(2002-11-16T00:00:00), DateTime360Day(2002-12-16T00:00:00)] (Sampled: Ordered Irregular Points)\nand data: 180×170×24 Array{Union{Missing, Float32},3}\n[:, :, 1]\n missing  missing     missing  …  271.437  271.445  271.459\n missing  missing     missing     271.438  271.445  271.459\n...\n\nNow plot every third month in the first year, just using the regular index:\n\njulia> using Plots\n\njuila> A[Ti(1:3:12)] |> plot\n\n(Image: Global ocean surface temperatures)\n\nNow plot Australia in the first month of 2001. Notice we are using lat/lon coordinates  and date/time instead of regular indexes:\n\njulia> A[Ti(Near(DateTime360Day(2001, 01, 17))), \n         Lat(Between(0.0, -50.0)), \n         Lon(Between(100.0, 160.0))] |> plot\n\n(Image: Australia regional ocean surface temperature)\n\nNow get the mean over the timespan, then save it to disk, and plot it :\n\njulia> using Statistics\njulia> mean_tos = mean(A; dims=Ti)\nGeoArray (named tos) with dimensions:\n Longitude (type Lon): Float64[1.0, 3.0, …, 357.0, 359.0] (Converted: Ordered Regular Intervals)\n Latitude (type Lat): Float64[-79.5, -78.5, …, 88.5, 89.5] (Converted: Ordered Regular Intervals)\n Time (type Ti): DateTime360Day[2001-01-16T00:00:00] (Sampled: Ordered Irregular Points)\nand data: 180×170×1 Array{Union{Missing, Float32},3}\n[:, :, 1]\n missing  missing     missing     missing  …  271.434  271.443  271.454\n missing  missing     missing     missing     271.434  271.443  271.454\n...\n\njulia> write(\"mean.ncd\", NCDarray, mean_tos)\n    Writing netcdf...\n        key: \"longitude\" of type: Float64\n        key: \"latitude\" of type: Float64\n        key: \"time\" of type: DateTime360Day\n        key: \"tos\" of type: Union{Missing, Float32}\n\"mean.ncd\"\n\njulia> plot(mean_tos; color=:viridis) \n\n(Image: Mean temperatures)\n\nPlotting recipes in DimensionalData.jl are the fallback for GedData.jl when  the object doesn't have both Lat and Lon dimensions. So (as a random example) we  could plot a transect of ocean surface temperature at 20 degree latitude :\n\nA[Lat(Near(20.0)), Ti(1)] |> plot\n\n(Image: Temperatures at lattitude 20-21)\n\nGeoData.jl provides a range of other methods that are being added to over time. One example is aggregate, that can aggregate GeoArray by axis-specific amounts:\n\njulia> aggregate(mean, A, (Ti(12), Lat(20), Lon(20))\n\nGeoArray (named tos) with dimensions:\n Longitude (type Lon): Float64[21.0, 61.0, …, 301.0, 341.0] (Converted: Ordered Regular Intervals)\n Latitude (type Lat): Float64[-69.5, -49.5, …, 50.5, 70.5] (Converted: Ordered Regular Intervals)\n Time (type Ti): DateTime360Day[2001-01-16T00:00:00, 2002-01-16T00:00:00] (Sampled: Ordered Irregular Points)\nand data: 9×8×2 Array{Union{Missing, Float32},3}\n[:, :, 1]\n missing  277.139        missing     missing     missing     missing  missing  missing\n missing  277.126        missing     missing     missing     missing  missing  missing\n\nThis will also work for entire GeoStacks and GeoSeries using the same syntax.\n\nWorks in progress\n\nIntegration with Vector/DataFrame spatial types and point/line/polygon data types. It should be possible to select polygons of data, and convert between linear datasets and array formats.\nStandardised handling and conversion of spatial metadata between data formats\nHandling complex projections: Affine transformation of dimensions to indices. AffineMaps will be stored as a wrapper dimension in dims.\nLoad and write the NetCDF projection format.\n\n\n\n\n\n","category":"module"},{"location":"#Dimensions","page":"GeoData.jl","title":"Dimensions","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GeoData.GeoXDim\nGeoData.GeoYDim\nGeoData.GeoZDim\nLat\nLon\nVert\nBand","category":"page"},{"location":"#GeoData.GeoXDim","page":"GeoData.jl","title":"GeoData.GeoXDim","text":"GeoXDim <: Dimension.XDim\n\nAbstract supertype for GeoSpatial X dimensions. \n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoYDim","page":"GeoData.jl","title":"GeoData.GeoYDim","text":"GeoXDim <: Dimension.XDim\n\nAbstract supertype for GeoSpatial Y dimensions. \n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoZDim","page":"GeoData.jl","title":"GeoData.GeoZDim","text":"GeoZDim <: Dimension.ZDim\n\nAbstract supertype for GeoSpatial Z dimensions. \n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Lat","page":"GeoData.jl","title":"GeoData.Lat","text":"Lat <: GeoYDim\n\nLat(val=:)\n\nLatitude Dimension.\n\nExample:\n\nvertdim = Lat(10:10:100)\n# Or\nval = A[Lat(1)]\n# Or\nmean(A; dims=Lat)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Lon","page":"GeoData.jl","title":"GeoData.Lon","text":"Lon <: GeoXDim\n\nLon(val=:)\n\nLongitude Dimension.\n\nExample:\n\nlongdim = Lon(10:10:100)\n# Or\nval = A[Lon(1)]\n# Or\nmean(A; dims=Lon)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Vert","page":"GeoData.jl","title":"GeoData.Vert","text":"Vert <: GeoZDim\n\nVert(val=:)\n\nVertical Dimension.\n\nExample:\n\nvertdim = Vert(10:10:100)\n# Or\nval = A[Vert(1)]\n# Or\nmean(A; dims=Vert)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Band","page":"GeoData.jl","title":"GeoData.Band","text":"Band <: Dimension\n\nBand(val=:)\n\nBand Dimension for multi-band rasters.\n\nExample:\n\nbanddim = Band(10:10:100)\n# Or\nval = A[Band(1)]\n# Or\nmean(A; dims=Band)\n\n\n\n\n\n","category":"type"},{"location":"#Index-modes","page":"GeoData.jl","title":"Index modes","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GeoData.AbstractProjected\nProjected\nMapped","category":"page"},{"location":"#GeoData.AbstractProjected","page":"GeoData.jl","title":"GeoData.AbstractProjected","text":"AbstractProjected <: AbstractSampled\n\nAbstract supertype for projected index modes.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Projected","page":"GeoData.jl","title":"GeoData.Projected","text":"Projected <: AbstractProjected\n\nProjected(order, span, sampling, crs, mappedcrs)\nProjected(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs, mappedcrs=nothing)\n\nAn AbstractSampled IndexMode with projections attached.\n\nFields and behaviours are identical to Sampled with the addition of crs and mappedcrs fields.\n\nIf both crs and mappedcrs fields contain CRS data (in a GeoFormat wrapper from GeoFormatTypes.jl) the selector inputs and plot axes will be converted from and to the specified mappedcrs projection automatically. A common use case would be to pass mappedcrs=EPSG(4326) to the constructor when loading eg. a GDALarray:\n\nGDALarray(filename; mappedcrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf mappedcrs is not supplied (ie. mappedcrs=nothing), the base index will be shown on plots, and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Mapped","page":"GeoData.jl","title":"GeoData.Mapped","text":"Mapped <: AbstractProjected\n\nMapped(order, span, sampling, crs, mappedcrs)\nMapped(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs=nothing, mappedcrs)\n\nAn AbstractSampled IndexMode, where the dimension index has been mapped to another projection, usually lat/lon or EPSG(4326).\n\nFields and behaviours are identical to Sampled with the addition of crs and mappedcrs fields.\n\nThe mapped dimension index will be used as for Sampled, but to save in another format the underlying projectioncrs may be used.\n\n\n\n\n\n","category":"type"},{"location":"#Array","page":"GeoData.jl","title":"Array","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"geoarray\nAbstractGeoArray\nMemGeoArray\nDiskGeoArray\nGeoArray\nGeoData.OpenGeoArray","category":"page"},{"location":"#GeoData.geoarray","page":"GeoData.jl","title":"GeoData.geoarray","text":"geoarray(filename; kw...) => AbstractGeoArray\n\nLoad a file path as AbstractGeoArray. \n\nKeywords\n\nPassed to the constructor for the file type, and commmonly include:\n\ncrs: crs to use instead of the detected crs.\nmappedcrs: CRS format like EPSG(4326) used in Selectors like Between and At, and   for plotting. Can be any CRS GeoFormat from GeoFormatTypes.jl, like WellKnownText.\nname: Symbol name for the array.\ndims: Tuple of Dimensions for the array. Detected automatically, but can be passed in.\nrefdims: Tuple of position Dimensions the array was sliced from.\nmissingval: Value reprsenting missing values. Detected automatically when possible, but   can be passed it.\nmetadata: Metadata object for the array. Detected automatically but can be passed in.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.AbstractGeoArray","page":"GeoData.jl","title":"GeoData.AbstractGeoArray","text":"AbstractGeoArray <: DimensionalData.AbstractDimArray\n\nAbstract supertype for objects that wrap an array (or location of an array)  and metadata about its contents. It may be memory (GeoArray) or disk-backed (NCDarray, GDALarray, GRDarray).\n\nAbstractGeoArrays inherit from AbstractDimArray from DimensionalData.jl. They can be indexed as regular Julia arrays or with DimensionalData.jl Dimensions. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with getindex or view. getindex on a AbstractGeoArray will always return a memory-backed GeoArray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoArray","page":"GeoData.jl","title":"GeoData.MemGeoArray","text":"Abstract supertype for all memory-backed GeoArrays where the data is an array.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoArray","page":"GeoData.jl","title":"GeoData.DiskGeoArray","text":"DiskGeoArray <: AbstractGeoArray\n\nAbstract supertype for all disk-backed GeoArrays. For these the data is lazyily loaded from disk.\n\nTo load a DiskGeoArray and operate on the data multiple times, use open and a do block.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoArray","page":"GeoData.jl","title":"GeoData.GeoArray","text":"GeoArray <: MemGeoArray\n\nGeoArray(A::AbstractArray{T,N}, dims::Tuple; kw...)\nGeoArray(A::AbstractArray{T,N}; dims, kw...)\nGeoArray(A::AbstractGeoArray; kw...) =\n\nA generic, memory-backed spatial array type. All AbstractGeoArray are converted to GeoArray when indexed or otherwise transformed.\n\nKeywords\n\ndata: can replace the data in an AbstractGeoArray\ndims: Tuple of Dimensions for the array.\nrefdims: Tuple of position Dimensions the array was sliced from,   defaulting to ().\nname: Symbol name for the array.\nmissingval: Value reprsenting missing values, defaulting to missing.   can be passed it.\nmetadata: ArrayMetadata object for the array, or NoMetadata().\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.OpenGeoArray","page":"GeoData.jl","title":"GeoData.OpenGeoArray","text":"OpenGeoArray <: AbstractGeoArray\n\nUsed internally to expose open disk files inside a do block\n\n\n\n\n\n","category":"type"},{"location":"#Stack","page":"GeoData.jl","title":"Stack","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"stack\nAbstractGeoStack\nMemGeoStack\nGeoStack\nDiskGeoStack\nDiskStack\nSMAPstack","category":"page"},{"location":"#GeoData.stack","page":"GeoData.jl","title":"GeoData.stack","text":"stack(filename; kw...) => AbstractGeoStack\nstack(filenames::NamedTuple; kw...) => AbstractGeoStack\n\nLoad a file path or a NamedTuple of paths as an AbstractGeoStack.\n\nArguments\n\nfilename: A NamedTuple of stack keys and String filenames.\n\nKeywords\n\nPassed to the constructor for the file type, and commmonly include:\n\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the   contained arrays when they are accessed.\nmetadata: Metadata as a StackMetadata object.\nchild_kwargs: A NamedTuple of keyword arguments to pass to the childtype constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\nfiles = (:temp=\"temp.tif\", :pressure=\"pressure.tif\", :relhum=\"relhum.tif\")\nstack = stack(files; child_kwargs=(mappedcrs=EPSG(4326),))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.AbstractGeoStack","page":"GeoData.jl","title":"GeoData.AbstractGeoStack","text":"AbstractGeoStack\n\nAbstract supertype for objects that hold multiple AbstractGeoArray that share spatial bounds.\n\nThey are NamedTuple-like structures that may either contain NamedTuple of AbstractGeoArray, string paths that will load AbstractGeoArray, or a single path that points to as a file itself containing multiple layers, like NetCDF or HDF5. Use and syntax is similar or identical for all cases.\n\ngetindex on a AbstractGeoStack generally returns a memory backed standard GeoArray. geoarray[:somelayer] |> plot plots the layers array, while geoarray[:somelayer, Lon(1:100), Band(2)] |> plot will plot the subset without loading the whole array.\n\ngetindex on a AbstractGeoStack with a key returns another stack with getindex applied to all the arrays in the stack.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoStack","page":"GeoData.jl","title":"GeoData.MemGeoStack","text":"MemGeoStack <: AbstractGeoStack\n\nAbstract supertype for AbstractGeoStack stored in memory.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoStack","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack <: MemGeoStack\n\nGeoStack(data...; keys, kwargs...)\nGeoStack(data::Union{Vector,Tuple}; keys, kwargs...)\nGeoStack(data::NamedTuple; window=(), metadata=nothing, refdims=(), childkwargs=()) =\nGeoStack(s::AbstractGeoStack; [keys, data, refdims, window, metadata])\n\nA concrete MemGeoStack implementation. Holds layers of GeoArray.\n\nArguments\n\ndata: A NamedTuple of GeoArray, or a Vector, Tuple or splatted arguments   of GeoArray. The latter options must pass a keys keyword argument.\n\nKeywords\n\nkeys: Used as stack keys when a Tuple or Vector or splat of geoarrays are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the   contained arrays when they are accessed.\nrefdims: Reference dimensions from earlier subsetting.\nmetadata: Metadata as a DimensionalData.AbstractStackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoStack","page":"GeoData.jl","title":"GeoData.DiskGeoStack","text":"DiskGeoStack <: AbstractGeoStack\n\nAbstract supertype of AbstractGeoStacks stored on disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskStack","page":"GeoData.jl","title":"GeoData.DiskStack","text":"DiskStack(filenames...; keys, kw...)\nDiskStack(filenames; keys, kw...)\nDiskStack(filenames::NamedTuple; kw...)\n\nConcrete DiskGeoStack implementation. Loads a stack of files lazily from disk.\n\nArguments\n\nfilename: a NamedTuple of stack keys and String filenames.\n\nKeywords\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the   contained arrays when they are accessed.\nmetadata: Metadata as a DimensionalData.StackMetadata object.\nchildtype: The type of the child data. eg. GDALarray. Required.\nchildkwargs: A NamedTuple of keyword arguments to pass to the childtype constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstack","page":"GeoData.jl","title":"GeoData.SMAPstack","text":"SMAPstacka <: DiskGeoStack\n\nSMAPstack(filename::String; dims=nothing, refdims=nothing, window=())\n\nAbstractGeoStack for SMAP datasets.\n\nThe simplicity of the format means dims and metadata are the same for all stack layers, so we store them as stack fields.\n\nArguments\n\nfilename: String path to a SMAP .h5 file.\n\nKeywords\n\ndims: Dimensions held on the stack as all layers have identical Dimensions.   These are loaded from the HDF5 by default, but can be passed in to improve performance,   as is done by SMAPseries,\nrefdims: As for dims. Often the position time Dimension from the SMAPseries.\nmetadata: SMAPstackMetadata object. As for dims.\nwindow: Like view but lazy, for disk based data. Can be a tuple of Dimensions,   selectors or regular indices. These will be applied when the data is loaded or indexed.\n\n\n\n\n\n","category":"type"},{"location":"#Series","page":"GeoData.jl","title":"Series","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"series\nAbstractGeoSeries\nGeoSeries\nSMAPseries","category":"page"},{"location":"#GeoData.series","page":"GeoData.jl","title":"GeoData.series","text":"series(dirpath::AbstractString, dims; kw...) => AbstractGeoSeries\n\nLoad a vector of filepaths as a AbstractGeoSeries. kw are passed to the constructor.\n\ndims Dimensions can hold an index matching the files in the directory, or a function to convert the filename strings to index values.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.AbstractGeoSeries","page":"GeoData.jl","title":"GeoData.AbstractGeoSeries","text":"AbstractGeoSeries <: DimensionalData.AbstractDimensionalArray\n\nAbstract supertype for high-level DimensionalArray that hold stacks, arrays, or the paths they can be loaded from. GeoSeries are indexed with dimensions as with a AbstractGeoArray. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation. As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.\n\nThis allows syntax like:\n\nseries[Time(Near(DateTime(2001, 1))][:temp][Lat(Between(70, 150)), Lon(Between(-20,20))] |> plot`\n\nGeoSeries is the only concrete implementation. It includes a chiltype field indicating the constructor used then loading stacks or arrays of any type from disk, and holds a kwargs NamedTuple that will be splatted into to the keyword arguments of the childtype constructor. This gives control over the construction of lazy-loaded files.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoSeries","page":"GeoData.jl","title":"GeoData.GeoSeries","text":"GeoSeries <: AbstractGeoSeries\n\nGeoSeries(A::AbstractArray{<:AbstractGeoArray}, dims; kw...)\nGeoSeries(A::AbstractArray{<:AbstractGeoStack}, dims; kw...)\nGeoSeries(filenames::AbstractArray{<:AbstractString}, dims; kw...)\n\nConcrete implementation of AbstractGeoSeries. Series hold paths to array or stack files, along some dimension(s).\n\nKeywords\n\nrefdims: existing reference \nchildtype: type of child objects - an AbstractGeoSeries or AbstractGeoStack\nchildkwargs: keyword arguments passed to the child object on construction.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPseries","page":"GeoData.jl","title":"GeoData.SMAPseries","text":"SMAPseries(filenames::AbstractString; kw...)\nSMAPseries(filenames::Vector{<:AbstractString}, dims=nothing; kw...)\n\nGeoSeries loader for SMAP files and whole folders of files, organised along the time dimension. Returns a GeoSeries.\n\nArguments\n\nfilenames: A String path to a directory of SMAP files,   or a vector of String paths to specific files.\ndims: Tuple containing Ti dimension for the series.   Automatically generated form filenames unless passed in.\n\nKeywords\n\nkw: Passed to GeoSeries.\n\n\n\n\n\n","category":"function"},{"location":"#Sources","page":"GeoData.jl","title":"Sources","text":"","category":"section"},{"location":"#GRD","page":"GeoData.jl","title":"GRD","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"R GRD files can be loaded natively. The are always 3 dimensional, and have Lat, Lon and Band dimensions.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"If ArchGDAL.jl is loaded (to enable reprojection), they can have mappedcrs.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GRDarray\nGRDstack\nGRDdimMetadata\nGRDarrayMetadata","category":"page"},{"location":"#GeoData.GRDarray","page":"GeoData.jl","title":"GeoData.GRDarray","text":"GRDarray <: DiskGeoArray\n\nGRDarray(filename::String; kw...)\n\nA DiskGeoArray that loads .grd files lazily from disk.\n\nGRDarrays are always 3 dimensional, and have Lat, Lon and Band dimensions.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeywords\n\nmappedcrs: CRS format like EPSG(4326) used in Selectors like Between and At, and   for plotting. Can be any CRS GeoFormat from GeoFormatTypes.jl, like WellKnownText.\nname: String name for the array, taken from the files layername attribute unless passed in.\ndims: Tuple of Dimensions for the array. Detected automatically, but can be passed in.\nrefdims: Tuple of position Dimensions the array was sliced from.\nmissingval: Value reprsenting missing values. Detected automatically when possible, but   can be passed it.\nmetadata: Metadata object for the array. Detected automatically as   GRDarrayMetadata, but can be passed in.\n\nExample\n\nA = GRDarray(\"folder/file.grd\"; mappedcrs=EPSG(4326))\n# Select Australia using lat/lon coords, whatever the crs is underneath.\nA[Lat(Between(-10, -43), Lon(Between(113, 153)))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GRDstack","page":"GeoData.jl","title":"GeoData.GRDstack","text":"GRDstack(filenames; keys, kw...) => DiskStack\nGRDstack(filenames...; keys, kw...) => DiskStack\nGRDstack(filenames::NamedTuple; kw...) => DiskStack\n\nConvenience method to create a DiskStack of GRDarray from filenames.\n\nArguments\n\nfilenames: A NamedTuple of stack keys and String filenames, or a Tuple, Vector or splatted arguments of String filenames.\n\nKeywords\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the   contained arrays when they are accessed.\nmetadata: Metadata as a StackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the childtype constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\nExample\n\nCreate a GRDstack from four files, that sets the child arrays mappedcrs value when they are loaded.\n\nfiles = (:temp=\"temp.tif\", :pressure=\"pressure.tif\", :relhum=\"relhum.tif\")\nstack = GRDstack(files; childkwargs=(mappedcrs=EPSG(4326),))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.GRDdimMetadata","page":"GeoData.jl","title":"GeoData.GRDdimMetadata","text":"GRDdimMetadata <: AbstractDimMetadata\n\nGRDdimMetadata(val::Union{Dict,NamedTuple})\nGRDdimMetadata(pairs::Pair...) => GRDdimMetadata{Dict}\nGRDdimMetadata(; kw...) => GRDdimMetadata{NamedTuple}\n\nMetadata wrapper for GRDarray dimension metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GRDarrayMetadata","page":"GeoData.jl","title":"GeoData.GRDarrayMetadata","text":"GRDarrayMetadata <: AbstractArrayMetadata\n\nGRDarrayMetadata(val::Union{Dict,NamedTuple})\nGRDarrayMetadata(pairs::Pair...) => GRDarrayMetadata{Dict}\nGRDarrayMetadata(; kw...) => GRDarrayMetadata{NamedTuple}\n\nMetadata wrapper for GRDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#NetCDF","page":"GeoData.jl","title":"NetCDF","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"NetCDF files required NCDatasets.jl:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"import NCDatasets","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Single files can be treated as a array or a stack of arrays. ","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"NCDarray\nNCDstack\nNCDdimMetadata\nNCDarrayMetadata\nNCDstackMetadata","category":"page"},{"location":"#GeoData.NCDarray","page":"GeoData.jl","title":"GeoData.NCDarray","text":"NCDarray <: DiskGeoArray\n\nNCDarray(filename::AbstractString; name=nothing, refdims=(),\n         dims=nothing, metadata=nothing, crs=nothing, mappedcrs=EPSG(4326))\n\nA DiskGeoArray that loads that loads NetCDF files lazily from disk.\n\nThe first non-dimension layer of the file will be used as the array. Dims are usually detected as Lat, Lon, Ti, and [Vert] or possibly X, Y, Z when detected. Undetected dims will use the generic Dim{:name}.\n\nThis is an incomplete implementation of the NetCDF standard. It will currently handle simple files in lattitude/longitude projections, or projected formats if you manually specify crs and mappedcrs. How this is done may also change in future, including detecting and converting the native NetCDF projection format.\n\nArguments\n\nfilename: String pointing to a netcdf file.\n\nKeyword arguments\n\ncrs: defaults to lat/lon EPSG(4326) but may be any GeoFormat like WellKnownText. If the underlying data is in a different projection crs will need to be set to allow write to a different file format. In future this may be detected automatically.\ndimcrs: The crs projection actually present in the Dimension index Vector, which may be different to the underlying projection. Defaults to lat/lon EPSG(4326) but may be any crs GeoFormat.\nname: Symbol name for the array. Will use array key if not supplied.\ndims: Tuple of Dimensions for the array. Detected automatically, but can be passed in.\nrefdims: Tuple of position Dimensions the array was sliced from.\nmissingval: Value reprsenting missing values. Detected automatically when possible, but can be passed it.\nmetadata: Metadata object for the array. Detected automatically as NCDarrayMetadata, but can be passed in.\n\nExample\n\nA = NCDarray(\"folder/file.ncd\")\n# Select Australia from the default lat/lon coords:\nA[Lat(Between(-10, -43), Lon(Between(113, 153)))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDstack","page":"GeoData.jl","title":"GeoData.NCDstack","text":"NCDstack <: DiskGeoStack\n\nNCDstack(filename::String; refdims=(), window=(), metadata=nothing, childkwargs=())\nNCDstack(filenames; keys, kw...)\nNCDstack(filenames...; keys, kw...)\nNCDstack(filenames::NamedTuple; refdims=(), window=(), metadata=nothing, childkwargs=())\n\nA lazy AbstractGeoStack that uses NCDatasets.jl to load NetCDF files. Can load a single multi-layer netcdf file, or multiple single-layer netcdf files. In multi-file mode it returns a regular GeoStack with a childtype of NCDarray.\n\nIndexing into NCDstack with layer keys (Symbols) returns a GeoArray. Dimensions are usually detected as Lat, Lon, Ti, and [Vert] or X, Y, Z when detected. Undetected dims use the generic Dim{:name}.\n\nArguments\n\nfilename: Tuple or Vector or splatted arguments of String, or single String path, to NetCDF files.\n\nKeyword arguments\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in. These default to the first non-dimension data key in each NetCDF file.\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the contained arrays when they are accessed.\nmetadata: A NCDstackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the NCDarray constructor.\n\nExamples\n\nstack = NCDstack(filename; window=(Lat(Between(20, 40),))\n# Or\nstack = NCDstack([fn1, fn1, fn3, fn4])\n# And index with a layer key\nstack[:soiltemp]\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDdimMetadata","page":"GeoData.jl","title":"GeoData.NCDdimMetadata","text":"NCDdimMetadata <: AbstractDimMetadata\n\nNCDdimMetadata(val::Union{Dict,NamedTuple})\nNCDdimMetadata(pairs::Pair...) => NCDdimMetadata{Dict}\nNCDdimMetadata(; kw...) => NCDdimMetadata{NamedTuple}\n\nMetadata wrapper for NCDarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDarrayMetadata","page":"GeoData.jl","title":"GeoData.NCDarrayMetadata","text":"NCDarrayMetadata <: AbstractArrayMetadata\n\nNCDarrayMetadata(val::Union{Dict,NamedTuple})\nNCDarrayMetadata(pairs::Pair...) => NCDarrayMetadata{Dict}\nNCDarrayMetadata(; kw...) => NCDarrayMetadata{NamedTuple}\n\nMetadata wrapper for NCDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDstackMetadata","page":"GeoData.jl","title":"GeoData.NCDstackMetadata","text":"NCDstackMetadata <: AbstractStackMetadata\n\nNCDstackMetadata(val::Union{Dict,NamedTuple})\nNCDstackMetadata(pairs::Pair...) => NCDstackMetadata{Dict}\nNCDstackMetadata(; kw...) => NCDstackMetadata{NamedTuple}\n\nMetadata wrapper for NCDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GDAL","page":"GeoData.jl","title":"GDAL","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GDAL requires ArchGDAL.jl to be available: ","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"import ArchGDAL","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GDALarray\nGDALstack\nGDALdimMetadata\nGDALarrayMetadata","category":"page"},{"location":"#GeoData.GDALarray","page":"GeoData.jl","title":"GeoData.GDALarray","text":"GDALarray(filename; kw...)\n\nLoad a file lazily using gdal. GDALarray will be converted to GeoArray after indexing or other manipulations. GeoArray(GDALarray(filename)) will do this immediately.\n\nGDALarrays are always 3 dimensional, and have Lat, Lon and Band dimensions.\n\nArguments\n\nfilename: String pointing to a tif or other file that GDAL can load.\n\nKeywords\n\ncrs: crs to use instead of the detected crs\nmappedcrs: CRS format like EPSG(4326) used in Selectors like Between and At, and   for plotting. Can be any CRS GeoFormat from GeoFormatTypes.jl, like WellKnownText.\nname: Symbol name for the array.\ndims: Tuple of Dimensions for the array. Detected automatically, but can be passed in.\nrefdims: Tuple of position Dimensions the array was sliced from.\nmissingval: Value reprsenting missing values. Detected automatically when possible, but   can be passed it.\nmetadata: Metadata object for the array. Detected automatically as   GDALarrayMetadata, but can be passed in.\n\nExample\n\nA = GDALarray(\"folder/file.tif\"; mappedcrs=EPSG(4326))\n# Select Australia using lat/lon coords, whatever the crs is underneath.\nA[Lat(Between(-10, -43), Lon(Between(113, 153)))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALstack","page":"GeoData.jl","title":"GeoData.GDALstack","text":"GDALstack(filenames; keys, kw...)\nGDALstack(filenames...; keys, kw...)\nGDALstack(filenames::NamedTuple; kw...)\n\nConvenience method to create a DiskStack  of GDALarray from filenames.\n\nLoad a stack of files lazily from disk.\n\nArguments\n\nfilenames: A NamedTuple of stack keys and String filenames, or a Tuple,   Vector or splatted arguments of String filenames.\n\nKeyword arguments\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the   contained arrays when they are accessed.\nmetadata: a DimensionalData.StackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the childtype constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\nExample\n\nCreate a GDALstack from four files, that sets the child arrays mappedcrs value when they are loaded.\n\nfiles = (:temp=\"temp.tif\", :pressure=\"pressure.tif\", :relhum=\"relhum.tif\")\nstack = GDALstack(files; childkwargs=(mappedcrs=EPSG(4326),))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.GDALdimMetadata","page":"GeoData.jl","title":"GeoData.GDALdimMetadata","text":"GDALdimMetadata <: AbstractDimMetadata\n\nGDALdimMetadata(val::Union{Dict,NamedTuple})\nGDALdimMetadata(pairs::Pair...) => GDALdimMetadata{Dict}\nGDALdimMetadata(; kw...) => GDALdimMetadata{NamedTuple}\n\nMetadata wrapper for GDALarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALarrayMetadata","page":"GeoData.jl","title":"GeoData.GDALarrayMetadata","text":"GDALarrayMetadata <: AbstractArrayMetadata\n\nGDALarrayMetadata(val::Union{Dict,NamedTuple})\nGDALarrayMetadata(pairs::Pair...) => GDALarrayMetadata{Dict}\nGDALarrayMetadata(; kw...) => GDALarrayMetadata{NamedTuple}\n\nMetadata wrapper for GDALarray.\n\n\n\n\n\n","category":"type"},{"location":"#SMAP","page":"GeoData.jl","title":"SMAP","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"The Soil Moisture Active-Passive dataset provides global layers of soil moisture, temperature and other related data.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"It uses a custom format of HDF5 files, so required HDF5.jl to be available:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"import HDF5","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Files must be downloaded manually due to authentication restrictions. As the datasets are know files in standardised formats, whole folders can be loaded using SMAPseries. Methods like aggregate can be done over whole folders of stacks of data with a single command.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"SMAPdimMetadata\nSMAParrayMetadata\nSMAPstackMetadata","category":"page"},{"location":"#GeoData.SMAPdimMetadata","page":"GeoData.jl","title":"GeoData.SMAPdimMetadata","text":"SMAPdimMetadata <: AbstractDimMetadata\n\nSMAPdimMetadata(val::Union{Dict,NamedTuple})\nSMAPdimMetadata(pairs::Pair...) => SMAPdimMetadata{Dict}\nSMAPdimMetadata(; kw...) => SMAPdimMetadata{NamedTuple}\n\nDimMetadata wrapper for SMAParray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAParrayMetadata","page":"GeoData.jl","title":"GeoData.SMAParrayMetadata","text":"SMAParrayMetadata <: AbstractArrayMetadata\n\nSMAParrayMetadata(val::Union{Dict,NamedTuple})\nSMAParrayMetadata(pairs::Pair...) => SMAParrayMetadata{Dict}\nSMAParrayMetadata(; kw...) => SMAParrayMetadata{NamedTuple}\n\nArrayMetadata wrapper for SMAParray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstackMetadata","page":"GeoData.jl","title":"GeoData.SMAPstackMetadata","text":"SMAPstackMetadata <: AbstractStackMetadata\n\nSMAPstackMetadata(val::Union{Dict,NamedTuple})\nSMAPstackMetadata(pairs::Pair...) => SMAPstackMetadata{Dict}\nSMAPstackMetadata(; kw...) => SMAPstackMetadata{NamedTuple}\n\nStackMetadata wrapper for SMAPstack.\n\n\n\n\n\n","category":"type"},{"location":"#Helper-methods","page":"GeoData.jl","title":"Helper methods","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"See DimensionalData.jl docs for the majority of types and methods that can be used in GeoData.jl.  GeoData.jl is a direct extension of DimensionalData.jl.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"These methods are specific to GeoData.jl:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"replace_missing\nresample\nboolmask\nmissingmask\naggregate\naggregate!\ndisaggregate\ndisaggregate!\nconvertmode\nreproject","category":"page"},{"location":"#GeoData.replace_missing","page":"GeoData.jl","title":"GeoData.replace_missing","text":"replace_missing(a::AbstractGeoArray, newmissingval)\nreplace_missing(a::AbstractGeoStack, newmissingval)\n\nReplace missing values in the array or stack with a new missing value, also updating the missingval field/s.\n\nA GeoArray containing a newly allocated Array is always returned, even when the missing value matches the current value.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.resample","page":"GeoData.jl","title":"GeoData.resample","text":"resample(A::AbstractGeoArray, resolution::Number;\n\t\t crs::GeoFormat=crs(A), method::String=\"near\")\nresample(A::AbstractGeoArray, snap::AbstractGeoArray; method::String=\"near\")\n\nresample uses ArchGDAL.gdalwarp to resample an AbstractGeoArray.\n\nArguments\n\nA: The AbstractGeoArray to resample.\nresolution: A Number specifying the resolution for the output.   If the keyword argument crs (described below) is specified, resolution must be in units of the crs.\nsnap: an AbstractGeoArray whos resolution, crs and bounds will be snapped to.   For best results it should roughly cover the same extent, or a subset of A.\n\nKeywords\n\ncrs: A GeoFormatTypes.GeoFormat specifying an output crs   (A with be reprojected to crs in addition to being resampled). Defaults to crs(A)\nmethod: A String specifying the method to use for resampling. Defaults to \"near\"   (nearest neighbor resampling). See resampling method   in the gdalwarp docs for a complete list of possible values.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.boolmask","page":"GeoData.jl","title":"GeoData.boolmask","text":"boolmask(A::AbstractArray, [missingval])\n\nCreate a mask array of Bool values, from any AbstractArray. For AbstractGeoArray the default missingval is missingval(A), for all other AbstractArrays it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.missingmask","page":"GeoData.jl","title":"GeoData.missingmask","text":"missingmask(A::AbstractArray, [missingval])\n\nCreate a mask array of missing or true values, from any AbstractArray. For AbstractGeoArray the default missingval is missingval(A), for all other AbstractArrays it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, object, scale)\n\nAggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractGeoSeries, AbstractStack, AbstractGeoArray, Dimension\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate!","page":"GeoData.jl","title":"GeoData.aggregate!","text":"aggregate!(method, dst::AbstractDimArray, src::AbstractDimArray, scale)\n\nAggregate array src to array dst by scale, using method.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.disaggregate","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, object, scale)\n\nDisaggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractGeoSeries, AbstractStack, AbstractGeoArray, Dimension\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.disaggregate!","page":"GeoData.jl","title":"GeoData.disaggregate!","text":"disaggregate!(method, dst::AbstractDimArray, src::AbstractDimArray, scale)\n\nDisaggregate array src to array dst by some scale, using method.\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.convertmode","page":"GeoData.jl","title":"GeoData.convertmode","text":"convertmode(dstmode::Type{<:IndexMode}, x)\n\nConvert the dimension mode between Projected and Mapped. Other dimension modes pass through unchanged.\n\nThis is used to e.g. save a netcdf file to GeoTiff.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.reproject","page":"GeoData.jl","title":"GeoData.reproject","text":"reproject(source::GeoFormat, target::GeoFormat, dim::Dimension, val)\n\nreproject uses ArchGDAL.reproject, but implemented for a reprojecting a single dimension at a time.\n\n\n\n\n\n","category":"function"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Field access:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"missingval\ncrs\nmappedcrs\nmappedbounds\nmappedindex\ndata","category":"page"},{"location":"#GeoData.missingval","page":"GeoData.jl","title":"GeoData.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.crs","page":"GeoData.jl","title":"GeoData.crs","text":"crs(x)\n\nGet the projected coordinate reference system of a Lat or Lon Dimension, or of the Lat/Lon dims of an AbstractGeoArray.\n\nFor Mapped mode this may be nothing as there may be not projected coordinate reference system at all.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.mappedcrs","page":"GeoData.jl","title":"GeoData.mappedcrs","text":"mappedcrs(x)\n\nGet the mapped coordinate reference system for the Lat/Lon dims of an array.\n\nIn Projected mode this is used to convert Selector values form the mappedcrs defined projection to the underlying projection, and to show plot axes in the mapped projection.\n\nIn Mapped mode this is the coordinate reference system of the index values.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.mappedbounds","page":"GeoData.jl","title":"GeoData.mappedbounds","text":"mappedbounds(x)\n\nGet the bounds converted to the mappedcrs value.\n\nWhithout ArchGDAL loaded, this is just the regular bounds.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.mappedindex","page":"GeoData.jl","title":"GeoData.mappedindex","text":"mappedindex(x)\n\nGet the index value of a dimension converted to the mappedcrs value.\n\nWhithout ArchGDAL loaded, this is just the regular dim value.\n\n\n\n\n\n","category":"function"},{"location":"#DimensionalData.data","page":"GeoData.jl","title":"DimensionalData.data","text":"data(f, A::DiskGeoArray)\n\nRun method f on the data source object for A, as passed by the withdata method for the array. The only requirement of the object is that it has an Array method that returns the data as an array.\n\n\n\n\n\n","category":"function"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Not exported:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GeoData.filename\nGeoData.childkwargs","category":"page"},{"location":"#GeoData.filename","page":"GeoData.jl","title":"GeoData.filename","text":"filename(s::DiskGeoStack)\n\nReturn the filename field of a DiskGeoStack. This may be a Vector of String, or a String.\n\n\n\n\n\nfilename(s::DiskGeoStack, key)\n\nReturn the filename field of a DiskGeoStack for a given key.\n\nThis will always be a single string. However, in some cases all keys may have the same filename.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.childkwargs","page":"GeoData.jl","title":"GeoData.childkwargs","text":"childkwargs(s::AbstractGeoStack)\n\nReturns the keyword arguments that will be passed to the child array constructor.\n\n\n\n\n\n","category":"function"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"These Base and DimensionalData methods have specific GeoData.jl version:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"open\nwrite\ncat\ncopy!\nmodify","category":"page"},{"location":"#Base.open","page":"GeoData.jl","title":"Base.open","text":"open(f, A::AbstractGeoArray)\n\nopen is used to open any AbstractGeoArray and do multiple operations on it in a safe way. It's a shorthand for the unexported OpenGeoArray constructor.\n\nf is a method that accepts a single argument - an OpenGeoArray object which is just an AbstractGeoArray that holds an open disk - based object. Often it will be a do block:\n\nga = GDALarray(filepath)\nopen(ga) do A\n    A[I...] # A is an `OpenGeoArray` wrapping the disk-based object.\n    # ...  multiple things you need to do with the open file\nend\n\nBy using a do block to open file we ensure they are always closed again after we finish working with them.\n\n\n\n\n\n","category":"function"},{"location":"#Base.write","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, ::Type{GRDarray}, s::AbstractGeoArray)\n\nWrite a GRDarray to a .grd file, with a .gri header file. The extension of filename will be ignored.\n\nCurrently the metadata field is lost on write for GRDarray.\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, A::AbstractGeoArray; kw...)\n\nWrite any AbstractGeoArray to file, guessing the backend from the file extension.\n\nKeyword arguments are passed to the write method for the backend.\n\n\n\n\n\nBase.write(filename::AbstractString, T::Type{<:AbstractGeoArray}, s::AbstractGeoStack)\n\nWrite any AbstractGeoStack to file, guessing the backend from the file extension.\n\nKeyword arguments are passed to the write method for the backend.\n\nIf the source can't be saved as a stack-like object, individual array layers will be saved.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GDALarray}, A::AbstractGeoArray; kw...)\n\nWrite a GDALarray to file, .tif by default, but other GDAL drivers also work.\n\nKeywords\n\ndriver::String: a GDAL driver name. Guessed from the filename extension by default.\ncompress::String: GeoTIFF compression flag. \"DEFLATE\" by default.\ntiled::Bool: GeoTiff tiling. Defaults to true.\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDarray}, s::AbstractGeoArray)\n\nWrite an NCDarray to a NetCDF file using NCDatasets.jl\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDstack}, s::AbstractGeoStack)\n\nWrite an NCDstack to a single netcdf file, using NCDatasets.jl.\n\nCurrently DimMetadata is not handled, and ArrayMetadata from other AbstractGeoArray @types is ignored.\n\n\n\n\n\n","category":"function"},{"location":"#Base.cat","page":"GeoData.jl","title":"Base.cat","text":"Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)\n\nConcatenate all or a subset of layers for all passed in stacks.\n\nKeywords\n\nkeys: Tuple of Symbol for the stack keys to concatenate.\ndims: Dimension of child array to concatenate on.\n\nExample\n\nConcatenate the :seasurfacetemp and :humidity layers in the time dimension:\n\ncat(stacks...; keys=(:sea_surface_temp, :humidity), dims=Ti)\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy!","page":"GeoData.jl","title":"Base.copy!","text":"Base.copy!(dst::AbstractArray, src::DiskGeoStack, key::Key)\n\nCopy the stack layer key to dst, which can be any AbstractArray.\n\nExample\n\nCopy the :humidity layer from stack to array.\n\ncopy!(array, stack, :humidity)\n\n\n\n\n\nBase.copy!(dst::AbstractGeoStack, src::AbstractGeoStack, [keys=keys(dst)])\n\nCopy all or a subset of layers from one stack to another.\n\nExample\n\nCopy just the :sea_surface_temp and :humidity layers from src to dst.\n\ncopy!(dst::AbstractGeoStack, src::AbstractGeoStack, keys=(:sea_surface_temp, :humidity))\n\n\n\n\n\n","category":"function"},{"location":"#DimensionalData.modify","page":"GeoData.jl","title":"DimensionalData.modify","text":"modify(f, series::AbstractGeoStack)\n\nApply function f to the data of the child AbstractGeoArrays.\n\nf must return an idenically sized array.\n\nThis method triggers a complete rebuild of all objects, and disk based objects will be transferred to memory.\n\nThis is useful for swapping out array backend for an entire stack to CuArray from CUDA.jl to copy data to a GPU, and potentially other types like DAarray from Distributed.jl.\n\n\n\n\n\nmodify(f, series::AbstractGeoSeries)\n\nApply function f to the data of the child object. If the child is an AbstractGeoStack the function will be passed on to its child AbstractGeoArrays.\n\nf must return an idenically sized array.\n\nThis method triggers a complete rebuild of all objects, and disk based objects will be transferred to memory.\n\nThis is useful for swapping out array backend for an entire series to CuArray from CUDA.jl to copy data to a GPU, and potentially other types like DAarray from Distributed.jl.\n\n\n\n\n\n","category":"function"}]
}
